## 應用伺服器

- 所謂的 **應用伺服器; Application Server** 或 **API 伺服器; API Server** 的 Web 伺服器的類型是
  不只發送靜態的檔案內容，也擁有以下能力的 Web 伺服器
    - 生成動態內容
    - 隨著 Request 除了傳輸內容的計算外還進行二次處理
        - 基於 Request 內容在伺服器端儲存一些資料
        - 發送 Email
        - 對別的應用伺服器再發送 Request 以實現功能串接
        - 對儲存於伺服器端的大量資料進行如 **批次; Batch** 處理等的 **非同步** 處理
        - 這些被稱為 **副作用; Side-effect**
- **API; Application Programming Interface** 是出現於軟體開發中任何抽象層的詞語

---

- 生成動態內容，也就是
  「**基於 Request 的內容，執行於程式內處理，計算出要被送出的內容**」
  就這樣
- 所以，
    - 服務的開發者需要將欲實現的功能實作成程式，
    - 並且這個程式對接收到的 HTTP 請求做正確的回應
        - ＝以客戶端的角度看的話，必須與 Apache HTTP Server 之類的既有產品等做相同的請求處理
        - 像這樣，能夠根據特定 Protocol 進行請求的處理與回應，通常被稱為 **說**
- 當然 **如果 Internet 和 Web 的 Protocol 全部都自己做是很費勁的**
    - 對我來說實在沒辦法
- 因此，這些大部分都被 **隱藏** 後，開發者只需針對欲實現的功能（「商業邏輯」）進行程式的實作即可，
  之後只需將其組合之後運行就能成為 Web 伺服器，像這樣的 **框架; Framework** 存在著許多種

---

## 「動態生成」

- 雖然直接說是「動態」，依照 HTTP Request 也有許多因素使內容產生變動
    - 時間
    - 發送方(IP)
    - 發送方(**認證; Authentication** 資訊)
    - 發送方允許的瀏覽、操作的**權限; Privilege**
    - 附加資訊
        - HTTP 中除了 URL 以外也能加上 **標頭; header** 或 **body** （依據上下文也有可能是 payload）
        - URL 中也能夠添加隨 Request 不同而變動的資訊（**查詢; query parameter/query string** 或 **fragment/hash**）
    - 歷史
    - 內容的有效期限
    - etc...

---

- 發送靜態檔案的 Web 伺服器在許多情況下，也會有只透過執行時設定來進行根據驗證資訊的存在與否的查看限制
    - 使用 **Basic 驗證** 的查看限制等，從一開始就在各產品中有明確規定和共享的定義
    - 應用此種方法並不稱之為動態生成
- 動態生成的情況:
    - 並非在 Web 伺服器上有內容被（**永久化; persist**）保存的檔案實體，
    - 使用 **模板; Template** 系統讓顯示內容的一部份根據模板生成，
    - 或將保存於 **資料庫** 的資料依特定格式 **序列化; serialize** 之後，
        - Serialize 沒有很好的翻譯。也可以說是 **轉換; convert**，
          常用在「為了將某種結構化後的資料送出、保存而將其轉換為更好（較多是
          **machine-readable** 的）格式」
          的這種情況
    - 指建構每個 Request 所要送出資料的方式
- 這部分是筆者的感受，可能有更好的定義也說不定

---

## 應用伺服器的組成要素

- 在本文件中，眾所皆知的 HTTP 中定義了包括在 Request 中指定的 `GET/POST/PUT/DELETE` 等的
  **Method** （也叫做 **動詞; Verb**）
    - 各自都在 RFC 中規定了「是怎樣的請求」
      「伺服器對請求應該做什麼（**SHOULD**），或不能夠做什麼（**MUST NOT**）」
        - 被正確地實作的行為良好的 Web 伺服器的應用或框架通常都有遵守這樣的規則
        - 開發者可以自由地實作的應用伺服器也當然遵守 RFC 會比較好
        - **練習2**: 在練習1中所指定的 RFC 中有上述的 Method 定義，找出來讀讀看吧

---

- 應用伺服器也基於這樣的 HTTP 框架上來實現功能為目標
    - 當然也有基於 HTTP 以外的 Protocol 的情況
    - 也有直接在 TCP 上直接定義自己的 Protocol 的情況（在線上遊戲之類的很普遍）
    - 在 "Web" 應用伺服器的情況下雖然感覺都是默認地使用基於 HTTP 的 Protocol，
      但這部分的單字並沒有那麼明確地被區分開來
- 但是，HTTP 也只適用於一般情況，
  基於應用本身獨自的請求，也有需要 **依應用伺服器來自訂 Request 的格式**

---

- 有效的 Method 與 URL 的格式
    - 例) `GET /items`, `POST /comments`, `GET /users/:user_id`
        - 大多情況下，應用伺服器的 **主機名稱; hostname**（例如 `dev.io`）很多是另外定義的，
          通常如上述在路徑部分中定義（如果使用框架來實作的話，或者在 **API Documentation** 之中）
        - 上述的 `:user_id` 的部分表示 URL 中可變的部分（也就是變數）
            - 這樣的寫法在一些框架中可以實際在程式碼內使用，也用在 API Documentation 中
            - 另外也有像 `/users/<user_id>`, `/users/${user_id}` 這樣的寫法

---

- header 的類型與值的預期格式
    - 例) `Authorization` - 大多用來表示在伺服器中是 **驗證** 完成的情況之某種字串（**權杖; Token**）
    - 像這樣有特殊意義的，其用途與格式很多都在 RFC 中標準化了
- 使用 body 或 query，及其值的格式
    - 例) 「Body 是 **JSON（Javascript Object Notation）** 格式，
      且 `"password"` 欄位是用於驗證的密碼之字串」等等
    - 有 `Content-Type` 這個特別的 header 用於表示 Body 的內容是何種格式，
      在這邊將 **MINE Type** 正確地標記格式後，可以在客戶端與伺服器端之間傳送大量的資料
        - 這也是「標準化的 header」之一
