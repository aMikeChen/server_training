# サーバ開発基礎

---

## まえがき

- この文書は:
    - [@access-company]の新卒技術研修、座学資料
    - 2018年度作成
    - 文責は[@ymtszw]
    - 1時間程度を想定
    - 「サーバ開発基礎」のくくりである
    - といってもあまり系統立てられた「授業」はしたこともないしできないので、フワッフワした講義になるであろう
    - そもそも筆者個人が、「サーバ開発」に関して系統立った教育を受けたことはない
        - 筆者自身の新卒研修では、サーバサイドは Rails チュートリアルベースだったような記憶があるが、かなり前なので怪しい

[@access-company]: https://github.com/access-company
[@ymtszw]: https://github.com/ymtszw

---

## 前提知識: 「はじめにWebありき」

- 本文書では、"Web (World Wide Web; WWW)"は、大枠を既知とする
    - Web を実現している数々の要素技術について、概略として想像が及ぶこと
    - 権威ある論文や RFC, 教科書などに基づいた系統的な教育を受けていなくても、Web がどういったものかについて一般的な知識があれば今は充分
    - 以下のキーワードを聞いたことがあり、 **調べれば正式な定義や最新のコンセンサスに辿り着ける** と自分が思うならば問題なし
        - HTTP
        - DNS
        - URI / URL
        - HTML
- クライアント・サーバ(Client and Server)モデルの概念も既知とする

---

## 暗黙の前提技術: 「調べられること」

- 本文書は網羅的な教科書となることを目指さない。できねぇし
- 従って文章中にわからないことが出てきたら **自分で調べられること** を前提とする
    - 「そのときすぐ」でなくて良い。いずれ思い出して気になったとき、でも良い。脳内の「知らないこと領域」に追加すればよい
    - この領域は面白いデータ構造をしている。 cf. Algorithms and Data Structures; アルゴリズムとデータ構造
        - 追加した順に取り出せる(**Queue**)とは限らない。追加したのと逆順に取り出せる(**Stack**)とも限らない
        - 「重要かどうか」など、何らかの指標によって順序付けられている(**Heap**)わけでもない
        - 追加したが二度と取り出されないことが頻繁にあり得る
        - それどころか **追加したのに知らぬ間に消滅することもある**

---

- なにごとも、全て完璧に定義や公理まで遡って理解できなくても良い
    - そのとき興味のある部分までとりあえず掘り下げる
    - 過程で必ず新たな新事項がでてくるはずだが、時間があるならそこも掘ればいいし、なければ **遅延評価(Lazy evaluation)** する
        - 「知らないこと領域」にやはり突っ込んでおき、同じプロセスを辿らせる
        - 「そう言えば前もこの単語わからなかったな」という「気づき」はいわば **duplicated insert** である
            - とはいえ厳密な **一意性(uniqueness)** が存在する **集合(Set)** なのかはよくわからない
            - なんにせよ別々の機会に渡って複数回疑問を抱くというのは自分にとって重要である可能性と相関するはず
- そのようにして順に「知らないこと」を調べていくのが **何よりも重要な技術**
    - ちなみにいざ調べることが必要になったときにも「戦略」がありうる
        - 当座の対象について、大まかな理解を優先するなら **幅優先(Breadth-first)探索** する
        - どんどん掘り下げたい気分なら **深さ優先(Depth-first)探索** する
            - 深夜にやるのがオススメである。会社には遅刻する

---

- 本文書が伝えたいことのうち、 **実に7割くらいがこの「調べられること」の重要さ** である
    - そもそも「サーバ開発の基礎」だって、皆が個別に調べられるならば講義しなくても良いのだ
        - **並列(Parallel)** かつ **非同期(Asynchronous)** な形態である
        - 逆に複数人がこの資料を同時に読み進めながら座学講義するのは **同期的(Synchronous)** な処理である
            - 進捗は全員同じペースとなる
            - 全員の理解度を都度確認しながら進めるような場合は、最も理解に手こずっている人の速度に全体が合わせることにもなる
            - 一方で、よくわからなかった部分は「あとで調べればいいよ」などといって先に進むかも知れない
                - これは「**時間のかかる処理単位を非同期的実行に切り替える**」行為である。"Asynchronous job dispatch"などという
                - もしもこの「あとで」が、「必要になったときに改めて」などと読み替えられたならば、 **遅延評価** にも該当する

---

- はじめはどんな分野でも知らないことのほうが多いので、「何から手を付けていいかわからない」状態になりがち
    - 索引(**index**)なしで辞書を読むようなもの。たまに辞書を最初から最後まで読む輩とかもいるが。。。
- 本文書は、サーバ開発に関して「この辺が頻出/基礎/重要」「この辺がキーワード」「この辺が面白い」などを、
  ちょっとしたストーリーに沿って挙げていく。いわば分厚い辞書に付箋をうつことを目的とする
- 従って、 **この文書を読みつつ、ポイントとなりそうな事柄を自分で調べて、枝葉を広げるように進める** のが使い方となる
- 既に気づいているかも知れないが、そのためにいくつか仕掛けがある

---

- **太字** になっていたり、対応する英単語が併記されていたりするのは、
  筆者が重要だと思っているポイントや、「気になったら調べて欲しい事柄」である
    - 特に、固有名詞っぽいものや専門用語っぽいものは興味を持って欲しい
- リンクはあえて、ほとんどつけていない。(片っ端から付けるのが面倒だったというのもあるが、)
  **権威のありそうな情報源を特定する** のはこれもまた技術であり、練習してみてほしいからだ
    - 「一次情報源」の特定

---

## 「調べ方」の手引き

- Web関連の技術要素で広範に利用されているものであれば、
  IETF が中心となって業界関係者からなるグループで議論した上で、 **RFC(Request For Comment)** としてまとめてあることが多い
    - 厳正な議論とレビューのプロセスを経ており、権威ある情報源であることが多い
        - このことが保証するのは説明・定義として誤謬がなく信頼できるという点であって、
          その内容が現代の実務状況に照らして「使いやすい」「ベストな」ものとは限らないのは了解しておくこと
    - 例) [RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax](https://tools.ietf.org/html/rfc3986)
    - 読むときは、
        - "Status"や、
        - "Obsoletes: ..." 「〜を廃止する」(廃止して置き換える)や、
        - "Updates: ..." 「〜を更新する」に注意する
    - その文書が現在どのような扱いであるのか確認してから読む。既に廃止されたバージョンかもしれない
    - **演習1**: 2018年5月現在有効な HTTP version 1.1 の標準仕様を定めたRFC群(複数ある)を特定してみよう。手段は問わない
- ものによっては、その技術や概念は論文として発表されているかもしれない
    - **Google Scholar** はその検索のための極めて有用なサービス
    - 査読付き論文誌などに採択されていないものでも、 arXive で発表されているかも知れない

---

- 何らかのアプリケーションやフレームワークについて調べる際には、基本的にはそれらの開発元が提供している文書が確実である
    - ニュアンスとしては以下のような感じ:
        - "Guide": 実際に使用する方法を順序立てて流れとして説明する文書
        - "Reference": アプリケーションのコマンドやAPIなど、一つ一つの細かな仕様をまとめた文書
        - "Documentation": GuideとReferenceの中間
- ある分野に関連する語彙や概念についてまとめて一度に調べたいのであれば、書籍や解説サイトが有効
    - 書籍にはレビューがつきものなので、良し悪しを判定してから買うのが容易。先輩に聞くのも良い
        - 特に、既にある程度枯れた技術で、定番の解説書がある、といったケースではそれを読むのが手っ取り早い
    - 解説サイト・ブログなどはまさに玉石混淆なので油断ならない
        - 一般に、権威ある情報源や、関連する文書へのリンクを付与しつつ、
          その上で自分の言葉による噛み砕いた説明に落とし込もうとしている文書は、内容はともかく姿勢として信頼に値する
            - 要は書籍や論文と同じ
        - RFCや論文などへのリンク(参考文献リスト)がきちんとまとめられている限りにおいて、Wikipediaなどの記事も十分役立つ

---

- 大切なのは、どんな過程であれ **信頼できる情報に辿り着くための努力を惜しまない** こと
    - よくあるアンチパターン1: 「検索して最初にでてきたサイトを斜め読みしてわかった気になる」
    - よくあるアンチパターン2: 「StackOverflowからコピペ」
- 慣れてくれば、信頼できる情報に辿り着くための **ホップ数(hop count)** を減らせるようになる
    - RFCや公式ドキュメントなどの一次情報源を検索エンジン化して、ブラウザのアドレスバーからダイレクトに検索可能にする
    - その分野の代表的な研究者・開発者・開発企業をSNSでフォローしたり、ブログを購読したりして、最新情報を早く掴む

さて、ここまでが長い前置きで、ようやくサーバの話に入る

---

# [dev.to]を開いてみよう

[dev.to]: https://dev.to/

---

## [dev.to]

- 開発者向け情報投稿サービス
- 「表示が爆速」ということで話題になった
- The Practical Dev社によって開発運営されている
- 彼らは[**New York Cityを拠点としている**](https://dev.to/about)

---

## ブラウザの開発者ツールで見てみよう

- 別の講義でも紹介済みのはず
- macOSのChromeなら`Alt(Option) + Cmd + i`
    - 長い付き合いになるはずだ

![dev.to](devto.png)

(2018/05/01のある時刻に取得した画像)

---

## ここで復習: インターネットとWeb

- Webについて学習済みであるならば、以下のことは大体わかっているはず
- そもそも **インターネット; The Internet** とは、世界中にある計算機を有線あるいは無線の通信網で接続し、
  それぞれの間で意味のある情報を交換できるよう整備された系
- インターネットは様々なプロトコルの積み重ね(Protocol Stack)によって成り立つ
    - cf. **Internet Protocol Suite**, **TCP/IP**
- Webは、根本としては、 **URL** で表現される何らかの実体(**資源; Resource**)を、
  それを保管している計算機から取り寄せて閲覧するシステム
    - 対象となる実体は、多くの場合、人間が意味を理解できる文字からなる文書を、適切に **encode** したもの(データ、ファイル)
    - 画像・動画などは文字ではないかもしれないが、やはり人間が視覚的・聴覚的に理解できる情報を、適切に **encode** したもの
    - もちろん、人間を直接の対象読者とせず、プログラムの内部で計算機に使わせることだけを目的とするデータもありうる

---

## ここで復習: クラサバ, HTML, Webブラウザ

- 取り寄せようとする側を **クライアント; Client**, 設置場所の方を **サーバ; Server** とみなす
- **HTML** という形式で記述された文書を多様な用途に用いる
    - 多くの機能が規定されており、クライアントは **Webブラウザ** を使ってHTMLを閲覧することでこれらの機能を利用できる
        - 文書構造の定義(見出し、箇条書き、強調、装飾等)
        - 他の文書に対する言及、言及されている文書を簡単な操作で取得(**ハイパーリンク; Hyperlink**)
        - **CSS** と組み合わせることによる、文書構造を元にした視覚的な装飾表現の描画
- クライアントのWebブラウザ上で実行することで、閲覧時に文書内容を変動させたり、
  複雑な機能を実現したりするためのプログラムを配布することもある
    - 現代では、そのようなプログラムの多くは **JavaScript** で書かれる
    - 必然的に、多くのWebブラウザはHTML/CSSを解釈して文書を視覚的に描画する機構と同時に、
      JavaScriptプログラムを解釈して実行する機構も併せ持っている

---

## いわゆる「Webサーバ」

- クライアントからの **HTTP** 要求に基づいてデータを送信する機能をもつアプリケーションを **Webサーバ; Web Server**という
    - 代表的なのは **Apache HTTP Server**(**`httpd`**)
    - クラサバモデルにおける「サーバ」と同じ単語が使われている。
      このような文脈によって微妙に意味する内容が変わりうる語には常に注意が必要
    - Webサーバが稼働している計算機自体を指してWebサーバとも呼ぶ
- Webサーバは、最も基本的には、その計算機に装着された非揮発性記憶装置(たとえばSSD)上にあるファイルを読み出して、
  その内容をクライアントとの間で結ばれた **TCPソケット** 経由で送信する

---

## 再び[dev.to]

- ここまでさらったところで、改めてdev.toを閲覧した時の状況を見てみる
- (ざっと見方を口頭説明; あとから参照している場合は **Chrome devtools** で調べる)

![dev.to](devto2.png)

---

## 気づけること

- そもそも`dev.to`としか要求していない、つまり「ファイルパス」を与えていないにもかかわらず、意味のある情報が返ってきている
- `https://dev.to`という単一のURLを要求しただけなのに、大量のリクエストが付随して発生している
- **13msという速さ** で`dev.to`に対する冒頭のリクエストが完了している
- **さっきの画像と中身が違う**
- (ほかにも挙げてみよう)

---

> - そもそも`dev.to`としか要求していない、つまり「ファイルパス」を与えていないにもかかわらず、意味のある情報が返ってきている

- Webサーバは、必ずしもファイルを明示的に要求されて、それを返さなければならないというわけではない
    - `dev.to`部分(hostname)だけで「送信べき情報」が確定するのであれば、Webサーバはそれを送信する自由がある
    - この場合、`dev.to`とだけ要求された場合はサイトの「トップページ」を要求されたものとみなしているので、Webサーバはそれを送信した
        - 同じ慣習を採用しているWebサーバは多い
        - 逆に、古典的なファイルベースのサイトでは「トップページ」を意味するファイル実体として
          `index.html`などの"index"という名前を持つファイルを持っていることが多い
            - 「古典的」といっても、何も悪い意味ではない。この方式は現在も頻繁に使われる
    - `dev.to`と要求されたWebサーバは、
        - 「トップページ」の実体として存在するファイルを読み出して、その中身を送信しているのかもしれないし、
        - あるいは実体としてのファイルはWebサーバの記憶装置には存在せず、要求されたときにプログラムが都度生成しているのかもしれない
        - この2パターンはどちらもありうるが、 **クライアントから見た場合は一般に区別できない**
            - 結局の所クライアントに送り届けられるのはバイナリデータにすぎず、
              Webブラウザ等がそれを意味ある情報として解釈できる限りにおいては平等に扱われる

---

> - `https://dev.to`という単一のURLを要求しただけなのに、大量のリクエストが付随して発生している

- これはHTML文書、およびそれを解釈して描画する機能の一環として、
  「その文書自体とは別で存在する何らかのファイル」を追加で取得できる機能による
    - たとえばCSS, JS, 画像, 動画, 別のHTMLなど、様々なものを対象にできる
    - ("Type"列を眺めてみよう)

---

> - **13msという速さ** で`dev.to`に対する冒頭のリクエストが完了している

- ここで以下を思い出して欲しい:

    > - 彼らは[**New York Cityを拠点としている**](https://dev.to/about)

---

![Tokyo to NY](tokyo_ny.png)

- 約10,000km

---

- インターネットを成り立たせている通信回線網の根幹部分は光ファイバーケーブルからなる
- つまり1本のケーブル内での伝送速度は光速が上限となる(約300,000km/s)が、
  当然ながらケーブル内部で反射・屈折を繰り返すので、直線とはならない
    - 実用上は200,000km/s程度を上限とするらしい
- そして、極めて短い時間単位の光のon/offを元に、0と1からなるバイナリデータを表現する
    - このへんあまりに大雑把だが、本文書の対象とするレイヤではないので端折る

---

- 画像をよく見ると、`dev.to`が送信したデータのサイズは19.6KBとなっている
- 仮にNYのThe Practical Dev社までの間に、この約20KB(160KBits)を
  いっぺんに送受できるだけの帯域幅を実現する光ファイバーケーブルが引かれているとしても、
  200,000km/sごときでは50msもかかってしまう！
- どうやら、`dev.to`に対するリクエストに応答したWebサーバは、**NYではない、もっと東京に近い場所にあるらしい**
- 当然といえば当然だが、インターネットとその上に成り立つWebは、クライアントとサーバ、**どちらも物理的な場所に束縛されない**
    - アメリカのサービスでも、日本国内にWebサーバを置いて何ら問題ない
    - それどころか、**アメリカのクライアントはアメリカのWebサーバに応答させ、日本のクライアントは日本のWebサーバに応答させたって良い**

---

> - **さっきの画像と中身が違う**

- 単純に考えれば、内容がWebサーバ側で更新されたと推測できる
- 一方、既出の内容を思い出すと、別の実現方法も考えられる

    > - あるいは実体としてのファイルはWebサーバの記憶装置には存在せず、要求されたときにプログラムが都度生成しているのかもしれない

- あるURLが、提供者側で明示的に更新されない限り、「誰に対しても」「全く同じ内容を」「返し続ける」場合、これを **静的; static** な内容という
- 反対に、「クライアントによって」あるいは「タイミングによって」、「異なる内容を返す」場合、 **動的; dynamic** であるという
    - これらの言葉には注意が必要で、組み合わせもありうるし、「変化」がどのレイヤで行われているかも場合によって異なる
    - たとえば、リクエスト送信者によって送信内容をWebサーバ側で変えるようなケースもあれば、
      JavaScriptを利用してクライアント側で内容を変動させることもありうる
- `dev.to`は「爆速化」のためにあらゆる策を講じている。前項の、

    > - それどころか、**アメリカのクライアントはアメリカのWebサーバに応答させ、日本のクライアントは日本のWebサーバに応答させたって良い**

    - この手法とも組み合わせて、「どうしても遅くなる部分をユーザに気づかせない(**非同期** に処理する)」であったり、
      「一度生成した動的な内容をある程度の期間使いまわす(**キャッシュ; cache** する)」であったりといった工夫を行う

---

- いわゆる **アプリケーションサーバ; Application Server** や **APIサーバ; API Server** と呼ばれるWebサーバの類型は、
  静的なファイル内容の送信だけではなく、以下のような能力を持つWebサーバと言える
    - 動的なコンテンツ生成
    - リクエストに付随して、送信コンテンツの計算以外にも副次的な処理
        - リクエスト内容をもとに、サーバ側に何らかのデータを保存
        - メールを送信
        - 別のアプリケーションサーバに更にリクエストを送って連携した機能を実現
        - サーバ側に存在する大量のデータに対する **バッチ; Batch** 処理などの **非同期** 処理を開始
        - これらを **副作用; Side-effect** と言ったりする
- **API; Application Programming Interface** はソフトウェア開発のあらゆるレイヤで登場する語

---

- 動的なコンテンツ生成をする、ということは、
  「**リクエストの内容を元に、プログラムで定めた処理を行って、送信すべき内容を計算する**」ことにほかならない
- 従って、
    - そのサービスの開発者が、実現したい機能内容を自分たちでプログラムとして表現し、
    - かつ、そのプログラムがHTTP要求に対し正しい応答を行うことができる必要がある
        - ＝クライアントから見る限りにおいて、Apache HTTP Serverなどの既存製品と同等の要求処理をこなす
        - このように、特定のプロトコルに則った要求処理・応答ができることを指して、俗に **喋る** と言ったりする
- 当然ながら、**InternetとWebのプロトコルスタックをすべて自前で実装するのは骨が折れる**
    - ぼくにはとてもできない
- そこで、それらの大部分を**隠蔽**し、開発者は本質的に実現したい機能だけ(「ビジネスロジック」と呼ばれたりする)をプログラムとして実装すれば、
  あとは組み合わせて実行するだけでWebサーバとして振る舞うようになる、という **フレームワーク; Framework** が多数存在する

---

## 「動的生成」

- 一口に「動的」といっても、HTTPリクエストに対し、何を起因としてコンテンツを変動させるかは様々
    - 時刻
    - 送信者(IP)
    - 送信者(**認証; Authentication** 情報)
    - 送信者に認められた閲覧・操作の**権限; Privilege**
    - 付加情報
        - HTTPでは、URL以外にも **ヘッダ; header** や **body** (文脈によっては payload とも)を付与できる
        - URLの一部として、リクエストごとに変動しうる情報を付与することもある(**クエリ; query parameter/query string** や **fragment/hash**)
    - 履歴
    - コンテンツの有効期限
    - etc...

---

- 静的なファイルを送信するWebサーバでも、認証情報の有無による閲覧制限など、実行時設定だけで実現できることも多い
    - **Basic認証** を用いた閲覧制限など。明確な定義が規定・共有されており、様々な製品で最初から実装済み
    - このような手法の適用は、動的生成とはまず言わない
- 動的生成という場合は:
    - コンテンツをそのまま保存(**永続化; persist**)したファイル実体がWebサーバ上にあるわけではなく、
    - **テンプレート(ひな型; Template)** システムを用いて、表示内容の一部が変動する文書をひな型をもとに生成したり、
    - 後述する **データベース** に保存されているデータを、特定形式に **シリアライズ; serialize** したりして、
        - Serialize にはあまり良い訳語がない。 **変換; convert** といっても良いが、
          「何らかの構造化されたデータを送信・保管のために都合の良い(多くは **machine-readable** な)形式に変換する」
          というニュアンスでよく使われる
    - リクエストごとに送信するデータを構築する方式を指す

---

## アプリケーションサーバの構成要素

- 本文書では大枠で既知としているHTTPには、リクエスト時に指定する`GET/POST/PUT/DELETE`などの
  **Method** (**動詞; Verb** と呼ぶことも)が定義されている
    - それぞれが「どのような要求を意味するか」
      「サーバは要求に対し何をすべき(**SHOULD**)か、あるいは何をしてはいけない(**MUST NOT**)か」がRFCに規定されている
        - 行儀の良い、正しく実装されたWebサーバアプリケーションやフレームワークは、こういった規定を遵守していることが多い
        - 開発者が自由に実装できるアプリケーションサーバも、当然RFCを遵守するほうが都合の良いことが多い
        - **演習2**: 演習1で特定したRFCのどこかに、上記のような Method の定義がある。探して読んでみよう

---

- アプリケーションサーバも、こうしたHTTPの枠組みの上で、機能実現を目指すことになる
    - もちろん、HTTP以外のプロトコルをベースにすることもある
    - TCP上に直接独自のプロトコルを定義することもある(オンラインゲームなどでは日常的)
- ただし、HTTPの規定は一般的な内容を定めるに過ぎないので、
  アプリケーション独自の要請に基づき、 **リクエストの形式をアプリケーションサーバごとに定める** 必要がある

---

- 応答可能なMethodとURLの形式
    - 例) `GET /items`, `POST /comments`, `GET /users/:user_id`
        - 大抵の場合、アプリケーションサーバの **ホスト名; hostname** (例えば`dev.to`) は別で定義済みであることが多いので、
          上記のようにパス部分で定義することが多い(フレームワークを使った実装の際に、あるいは **API Documentation** 上で)
        - 上記の`:user_id`という部分は、URLの中で変動しうる部分(いわば変数)を示す
        - この書き方は一部のフレームワークで実際にコード内で使用されるほか、 API Documentation にも表れる
        - ほかには、`/users/<user_id>`, `/users/${user_id}`などと書き表すこともある
- 利用するheaderの種類、期待する値の形式
    - 例) `Authorization` - サーバに対して **認証** 済みであることを示す何らかの文字列(**トークン; Token**)を伝えるのによく用いられる
    - このような、特別な意味を持つとされていて、用途・形式がRFCで標準化済みのheaderも多い
- body/queryを利用するか、するならば期待する値の形式
    - 例) 「Bodyは **JSON (JavaScript Object Notation)** 形式で、
      `"password"`フィールドに、文字列で、認証のためのパスワードを格納していること」など
    - Bodyの中身がどのような形式であるかを示す特別なheaderとして`Content-Type`があり、
      ここに **MIME Type** で正しく形式を表明しておくことで、クラサバ間で誤解なく大きなデータの交換ができる
        - これも「標準化されたheader」の一つ

---

## アプリケーションサーバの流儀

- アプリケーションサーバ開発の大まかな流れとは:
    - リクエスト形式を規定し、
        - **API仕様; API specification** と呼ぶことが多い
    - 規定したリクエストに対応する機能を実現しつつ、
    - 規定したとおりの応答を行うよう、プログラムを実装する
- この際、どのようなAPI仕様とするか、**全くオリジナルに考えるのは苦労が多い**。
    - 何らかの指針があったほうが開発者としては嬉しいし、
    - 利用者側としても異なるサービス間で大まかな指針が共通していれば、理解が早い

---

- いくつかのAPI設計パターンが提唱されており、用途や適正に合わせて利用される
- **RESTful**
    - 「リソースに対する操作」を、
    - 「HTTPで定義済みのMethodを活用して表現」する、
    - 「**ステートレス; Stateless**」(後述)なプロトコル設計思想
    - 厳密なものから「なんちゃって」まで含めると、非常に幅広くWeb APIで利用されている
        - Bodyの形式(**IDL; Interface Description Language**)としては **XML** や **JSON** を使うことが多い
    - 問題点もある
        - 表現力が限定的。「リソース」と「それに対する操作」では表現しにくい処理も多くある
        - Bodyの形式を厳密に定義するための **スキーマ言語; Schema Language** とセットになっていない
            - 後付けのものは存在するが、使いにくかったり、表現力が低かったりする
            - 結果、API spec/documentationの形式がバラバラになったり、コード自動生成がしづらかったりする
        - 複数の処理を組み合わせるための統一的な手法がない
            - 複数のリソースへの処理を同時に行いたい場合に、複数のHTTPリクエストの発行が必要になりがち

---

- **grpc**
    - **HTTP 2.0** 上で実現するプロトコル
        - HTTP 2.0では一つのTCPコネクションを維持した上で、その中で複数のHTTPリクエストを往復させられる
    - IDLとして **Protocol Buffer (protobuf)** を用いる。 **スキーマ言語を同梱**
    - **RPC; Remote Procedure Call** は、その名の通り遠隔サーバ上に命令を送ること、及びその形式
        - 広い意味ではRESTful APIもRPCといえなくもない(と思う)が、あえてRPCと名乗るプロトコルの場合:
            - アプリケーションサーバ側で実行されるべき処理内容をより具体的に表現したリクエスト形式であることが多い
            - あるプロトコルを、そのRPCのリクエストを転送(**Transport**)するための手段としてだけ用い、
              そのプロトコルの流儀からは完全に独立している
                - 例) grpcでは、HTTP 2.0をTransport Protocolとして利用するが、
                  一旦接続が確立されたら、処理内容を決めるのはあくまでprotobufで表現されたBodyの中身のみ
                - 転送経路を確立したあとは、利用するのはBodyだけなので、URLはただ一つであることが多い
                - Transport Protocolは交換可能であることも多い。HTTP 1.1/2.0, **Websocket**, Raw TCP
            - ステートレスとは限らない
    - じわじわと利用が広がっている

---

- **GraphQL**
    - Query と Mutation という枠組みでリソースに対する操作を表現する方式
    - RESTfulの抱えるいくつかの問題に対するアンサーとなっており、
        - 複数の処理の組み合わせ記述
        - スキーマ言語
        - 取得する情報の絞込み、などの特長を備える
    - 多くはHTTP 1.1上で実現されるが、こちらもRPC的なインターフェイス(Bodyですべてを表現)であるため、
      原理的にはTransport Protocolはなんでも良い
    - ところどころ使われてはいる

---
