# サーバ開発基礎

---

## まえがき

- この文書は:
    - [@access-company]の新卒技術研修、座学資料
    - 2018年度作成
    - 文責は[@ymtszw]
    - 1時間程度を想定
        - してたけど、文量的にはとても収まらないと思われる。現場では適宜スキップする
    - 「サーバ開発基礎」のくくりである
    - といってもあまり系統立てられた「授業」はしたこともないしできないので、フワッフワした講義になるであろう
    - そもそも筆者個人が、「サーバ開発」に関して系統立った教育を受けたことはない
        - 筆者自身の新卒研修では、サーバサイドは Rails チュートリアルベースだったような記憶があるが、かなり前なので怪しい
- 内外の方へ: Issue/PRください

[@access-company]: https://github.com/access-company
[@ymtszw]: https://github.com/ymtszw

---

## 前提知識: はじめにWebありき

- 本文書では、"**Web (World Wide Web; WWW)**"は、大枠を既知とする
    - Web を実現している数々の要素技術について、概略として想像が及ぶこと
    - 系統的な教育を受けていなくても、Webがどういったものかについて一般的な知識があれば今は充分
    - 以下のようなキーワードについて、何を指しているかぐらいはわかっていれば問題なし
        - **TCP**
        - **HTTP**
        - **DNS**
        - **URI** / **URL**
        - **HTML**
- クライアント・サーバ(**Client and Server**)モデルの概念も既知とする

---

## 暗黙の前提1: 自ら調べられること

- 本文書は網羅的な教科書となることを目指さない。できねぇし
- 従って文章中にわからないことが出てきたら **自分で調べられること** を前提とする
    - 「そのときすぐ」でなくて良い。いずれ思い出して気になったとき、でも良い。脳内の「知らないこと領域」に追加すればよい
    - この領域は面白いデータ構造をしている。 cf. Algorithms and Data Structures; アルゴリズムとデータ構造
        - 追加した順に取り出せる(**Queue**)とは限らない。追加したのと逆順に取り出せる(**Stack**)とも限らない
        - 「重要かどうか」など、何らかの指標によって順序付けられている(**Heap**)わけでもない
        - 追加したが二度と取り出されないことが頻繁にあり得る
        - それどころか **追加したのに知らぬ間に消滅することもある**

---

- なにごとも、いきなり全て完璧に定義や公理まで遡って理解できなくても良い
    - そのとき興味のある部分までとりあえず掘り下げる
    - 過程で必ず新たな新事項がでてくるはずだが、時間があるならそこも掘ればいいし、なければ **遅延評価(Lazy evaluation)** する
        - 「知らないこと領域」にやはり突っ込んでおき、同じプロセスを辿らせる
        - 「そう言えば前もこの単語わからなかったな」という「気づき」はいわば **duplicated insert** である
            - とはいえ厳密な **一意性(uniqueness)** が存在する **集合(Set)** なのかはよくわからない
            - なんにせよ別々の機会に渡って複数回疑問を抱くというのは自分にとって重要である可能性と相関するはず
    - これを繰り返していけば、自然と源流まで遡っていくことができる

---

- そのようにして順に「知らないこと」を調べていくのが **何よりも重要な技術**
    - ちなみにいざ調べることが必要になったときにも「戦略」がありうる
        - 当座の対象について、大まかな理解を優先するなら **幅優先(Breadth-first)探索** する
        - どんどん掘り下げたい気分なら **深さ優先(Depth-first)探索** する
            - 深夜にやるのがオススメである。会社には遅刻する

---

- 本文書が伝えたいことのうち、 **実に7割くらいがこの「調べられること」の重要さ** である
    - そもそも「サーバ開発の基礎」だって、皆が個別に調べられるならば講義しなくても良いのだ
        - **並列(Parallel)** かつ **非同期(Asynchronous)** な形態である
        - 逆に複数人がこの資料を同時に読み進めながら座学講義するのは **同期的(Synchronous)** な処理である
            - 進捗は全員同じペースとなる
            - 全員の理解度を都度確認しながら進めるような場合は、最も理解に手こずっている人の速度に全体が合わせることにもなる
            - 一方で、よくわからなかった部分は「あとで調べればいいよ」などといって先に進むかも知れない
                - これは「**時間のかかる処理単位を非同期的実行に切り替える**」行為である。"Asynchronous job dispatch"などという
                - もしもこの「あとで」が、「必要になったときに改めて」などと読み替えられたならば、 **遅延評価** にも該当する

---

- はじめはどんな分野でも知らないことのほうが多いので、「何から手を付けていいかわからない」状態になりがち
    - 索引(**index**)なしで辞書を読むようなもの。たまに辞書を最初から最後まで読む輩とかもいるが。。。
- 本文書は、サーバ開発に関して「この辺が頻出/基礎/重要」「この辺がキーワード」「この辺が面白い」などを、
  ちょっとしたストーリーに沿って挙げていく。いわば分厚い辞書に付箋をうつことを目的とする
- 従って、 **この文書を読みつつ、ポイントとなりそうな事柄を自分で調べて、枝葉を広げるように進める** のが使い方となる
- 既に気づいているかも知れないが、そのためにいくつか仕掛けがある

---

- **太字** になっていたり、対応する英単語が併記されていたりするのは、
  筆者が重要だと思っているポイントや、「気になったら調べて欲しい事柄」である
    - 特に、固有名詞っぽいものや専門用語っぽいものは興味を持って欲しい
    - 英単語を付してあるのは、概して英語の方が資料も多く、権威ある情報源は英語であることが多いため
- リンクはあえて、ほとんどつけていない。(片っ端から付けるのが面倒だったというのもあるが、)
  **権威のありそうな情報源を特定する** のはこれもまた技術であり、練習してみてほしいからだ
    - 「一次情報源」の特定
    - とはいえそんなに難しいものでもなく、慣れを要する程度の話。どんどんやってみよう
- **同じ単語が再登場する**ことが複数回ある。行き来して文脈を確認してみて欲しい
    - 同じ意味で登場していることもあれば、
    - 文脈によって微妙に意味が異なっていることもあるはず
        - ソフトウェア開発の世界ではよくある

---

## 「調べ方」の手引き

- Web関連の技術要素で広範に利用されているものであれば、
  Internet Engineering Task Force; IETF が中心となって業界関係者からなるグループで議論した上で、
  **RFC(Request For Comment)** としてまとめてあることが多い
    - 長期間の議論と公開されたレビューのプロセスを経ており、権威ある情報源であることが多い
        - このことが保証するのは説明・定義として誤謬がなく信頼できるという点であって、
          その内容が現代の実務状況に照らして「使いやすい」「ベストな」ものとは限らないのは注意
    - 例) [RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax](https://tools.ietf.org/html/rfc3986)
    - 読むときは、
        - "Status"や、
        - "Obsoletes: ..." 「〜を廃止する」(廃止して置き換える)や、
        - "Updates: ..." 「〜を更新する」に注意する
    - その文書が現在どのような扱いであるのか確認してから読む。既に廃止されたバージョンかもしれない
    - **演習1**: 2018年5月現在有効な HTTP version 1.1 の標準仕様を定めたRFC群(複数ある)を特定してみよう。手段は問わない
- ものによっては、その技術や概念は論文として発表されているかもしれない
    - **Google Scholar** はその検索のための極めて有用なサービス
    - 査読付き論文誌などに採択されていないものでも、 arXive で発表されているかも知れない

---

- 何らかのアプリケーションやフレームワークについて調べる際には、基本的にはそれらの開発元が提供している文書が確実である
    - ニュアンスとしては以下のような感じ(異論は認める):
        - "Guide": 実際に使用する方法を順序立てて流れとして説明する文書
        - "Reference": アプリケーションのコマンドやAPIなど、一つ一つの細かな仕様をまとめた文書
        - "Documentation": GuideとReferenceの中間。どっち寄りかはものによる
- ある分野に関連する語彙や概念についてまとめて一度に知りたいのであれば、書籍や解説サイトが有効
    - 書籍にはレビューがつきものなので、良し悪しを判定してから買うのが容易。先輩に聞くのも良い
        - 特に、既にある程度枯れた技術で、定番の解説書がある、といったケースではそれを読むのが手っ取り早い
        - 新卒研修サイトに推薦図書集もあるので利用しよう。図書予算というのもちゃんとある
    - 解説サイト・ブログなどはまさに玉石混淆なので油断ならない
        - 一般に、権威ある情報源や、関連する文書へのリンクを付与しつつ、
          その上で自分の言葉による噛み砕いた説明に落とし込もうとしている文書は、内容はともかく姿勢として信頼に値する
            - 要は書籍や論文と同じ
        - RFCや論文などへのリンク(参考文献リスト)がきちんとまとめられている限りにおいて、Wikipediaなどの記事も十分役立つ

---

- 大切なのは、どんな過程であれ **信頼できる情報に辿り着くための努力を惜しまない** こと
    - よくあるアンチパターン1: 「検索して最初にでてきたサイトを斜め読みしてわかった気になる」
    - よくあるアンチパターン2: 「StackOverflowからコピペ」
- 慣れてくれば、信頼できる情報に辿り着くための **ホップ数(hop count)** を減らせるようになる
    - RFCや公式ドキュメントなどの一次情報源を検索エンジン化して、ダイレクトに検索可能にする
    - その分野の代表的な研究者・開発者・開発企業をSNSでフォローしたり、ブログを購読したりして、最新情報を早く掴む
    - 情報の流入量を増やしすぎて圧倒されないように、定期的にフィルタリングを改善する

---

## 暗黙の前提2: 実践

- 「調べる」ことに重きをおいて訴えているが、当然ながら**調べただけでは人間間違いなく忘れる**ので、
  何らかの形で手を動かして実践することをしないと知識は内面化(internalize)しない
    - 複数回調べることで反復によって覚えるというのもありだが、やっぱり肌感覚、体得というのは重要
    - 何かを行動に移したとき、必然的に外界からのフィードバックを受けるが、
      このときの不安、圧力のようなものが技術・知識の体得を促す燃料になる
        - 羽生善治先生も[「重圧を感ぜよ」と仰っている](http://www.hochi.co.jp/entertainment/20180430-OHT1T50154.html)
- とはいえ、業務において必要な内容については、自然と業務の中で体得する機会を得られると思っているので、ここは楽観視している
- 逆に、 **普段業務で直接使うことがあまりないが、ある程度理解しておかないとサービス・案件の全体設計・実装・運用に響いてくる分野** というのがクセモノ
    - 自分にとってそういった「畑違い」の分野こそ、意識的にキャッチアップするよう取り組んだり、
      ときにはコードを書いてみたりすることが大切だと思う

さて、ここまでが長い前置きで、ようやくサーバの話に入る

---

# [dev.to]を開いてみよう

[dev.to]: https://dev.to/

---

## [dev.to]

- 開発者向け情報投稿サービス
- 「**表示が爆速**」ということで話題になった
- The Practical Dev社によって開発運営されている
- 彼らは[**New York Cityを拠点としている**](https://dev.to/about)

---

## ブラウザの開発者ツールで見てみよう

- 別の講義でも紹介済みのはず
- macOSのChromeなら`Alt(Option) + Cmd + i`
    - 長い付き合いになるはずだ

![dev.to](devto.png)

(2018/05/01のある時刻に取得した画像)

---

## ここで復習: インターネットとWeb

- Webについて学習済みであるならば、以下のことは大体わかっているはず
- そもそも **インターネット; The Internet** とは、世界中にある計算機を有線あるいは無線の通信網で接続し、
  それぞれの間で意味のある情報を交換できるよう整備された系
- インターネットは様々なプロトコルの積み重ね(Protocol Stack)によって成り立つ
    - cf. **Internet Protocol Suite**, **TCP/IP**
- Webは、根本としては、 **URL** で表現される何らかの実体(**資源、リソース; Resource**)を、
  それを保管している計算機から取り寄せて閲覧するシステム
    - 対象となる実体は、多くの場合、人間が意味を理解できる文字からなる文書を、適切に **encode** したもの(データ、ファイル)
    - 画像・動画などは文字ではないかもしれないが、やはり人間が視覚的・聴覚的に理解できる情報を、適切に **encode** したもの
    - もちろん、人間を直接の対象読者とせず、プログラムの内部で計算機に使わせることだけを目的とするデータもありうる

---

## ここで復習: クラサバ, HTML, Webブラウザ

- 取り寄せようとする側を **クライアント; Client**, 設置場所の方を **サーバ; Server** とみなす
- **HTML** という形式で記述された文書を多様な用途に用いる
    - 多くの機能が規定されており、クライアントは **Webブラウザ** を使ってHTMLを閲覧することでこれらの機能を利用できる
        - 文書構造の定義(見出し、箇条書き、強調、装飾等)
        - 他の文書に対する言及、言及されている文書を簡単な操作で取得(**ハイパーリンク; Hyperlink**)
        - **CSS** と組み合わせることによる、文書構造を元にした視覚的な装飾表現の描画
- クライアントのWebブラウザ上で実行することで、閲覧時に文書内容を変動させたり、
  複雑な機能を実現したりするためのプログラムを配布することもある
    - 現代では、そのようなプログラムの多くは **JavaScript** で書かれる
    - 必然的に、多くのWebブラウザはHTML/CSSを解釈して文書を視覚的に描画する機構と同時に、
      JavaScriptプログラムを解釈して実行する機構も併せ持っている

---

## いわゆる「Webサーバ」

- クライアントからの **HTTP** 要求に基づいてデータを送信する機能をもつアプリケーションを **Webサーバ; Web Server**という
    - 代表的なのは **Apache HTTP Server**(**`httpd`**)
    - クラサバモデルにおける「サーバ」と同じ単語が使われている
    - Webサーバが稼働している計算機自体を指してWebサーバとも呼ぶ
    - 文脈によって微妙に意味する内容が変わりうる語には常に注意が必要
- Webサーバは、最も基本的には、
    - クライアントとの間で確立した **TCPソケット** を通して送られてくるHTTPリクエストを解釈し、
    - リクエストで指定されたファイルを、その計算機に装着された非揮発性記憶装置(たとえばSSD)から読み出して、
    - その内容を確率済みのTCPソケット経由で送信する

---

## 再び[dev.to]

- ここまでさらったところで、改めてdev.toを閲覧した時の状況を見てみる

![dev.to](devto2.png)

---

## 気づけること

- そもそも`dev.to`としか要求していない、つまり「ファイルパス」を与えていないにもかかわらず、意味のある情報が返ってきている
- `https://dev.to`という単一のURLを要求しただけなのに、大量のリクエストが付随して発生している
- **13msという速さ** で`dev.to`に対する冒頭のリクエストが完了している
- **さっきの画像と中身が違う**
- (ほかにも挙げてみよう)

---

> - そもそも`dev.to`としか要求していない、つまり「ファイルパス」を与えていないにもかかわらず、意味のある情報が返ってきている

- 実はWebサーバは、必ずしも「ファイル」を明示的に要求されて、それを返さなければならないというわけではない
    - 「**送信べき情報**」が確定したのであれば、Webサーバはそれを送信する自由がある
    - `dev.to`(hostname)だけを要求された場合はサイトの「トップページ」を要求されたものとみなしている
        - 同じ慣習を採用しているWebサーバは多い
        - 逆に、古典的なファイルベースのサイトでは「トップページ」を意味するファイル実体として
          `index.html`などの"index"という名前を持つファイルを持っていることが多い
            - 「古典的」といっても、悪い意味ではない。この方式は現在も頻繁に使われる
    - `dev.to`と要求されたWebサーバは、
        - 「トップページ」の実体として存在するファイルを読み出して、その中身を送信しているのかもしれないし、
        - あるいは実体としてのファイルはWebサーバの記憶装置には存在せず、要求されたときにプログラムが都度生成しているのかもしれない
        - この2パターンはどちらもありうるが、 **クライアントから見た場合は区別できない**
            - 結局の所クライアントに送り届けられるのはバイナリデータにすぎず、
              Webブラウザ等がそれを意味ある情報として解釈できる限りにおいては平等に扱われる

---

> - `https://dev.to`という単一のURLを要求しただけなのに、大量のリクエストが付随して発生している

- これはHTML文書、およびそれを解釈して描画する機能の一環として、
  「その文書自体とは別で存在する何らかのファイル」を追加で取得できる機能による
    - たとえばCSS, JS, 画像, 動画, 別のHTMLなど、様々なものを対象にできる
    - ("Type"列を眺めてみよう)

---

> - **13msという速さ** で`dev.to`に対する冒頭のリクエストが完了している

- ここで以下を思い出して欲しい:

    > - 彼らは[**New York Cityを拠点としている**](https://dev.to/about)

---

![Tokyo to NY](tokyo_ny.png)

- 約10,000km

---

- インターネットを成り立たせている通信回線網の根幹部分は光ファイバーケーブルからなる
- つまり1本のケーブル内での伝送速度は光速が上限となる(約300,000km/s)が、
  当然ながらケーブル内部で反射・屈折を繰り返すので、直線とはならない
    - 実用上は200,000km/s程度を上限とするらしい
- そして、極めて短い時間単位の光のon/offを元に、0と1からなるバイナリデータを表現する
    - このへんあまりに大雑把だが、本文書の対象とするレイヤではないので端折る
    - [Submarine communications cable](https://www.wikiwand.com/en/Submarine_communications_cable)

---

- 画像をよく見ると、`dev.to`が送信したデータのサイズは19.6KBとなっている
- 仮にNYのThe Practical Dev社までの間に、この約20KB(160KBits)を
  いっぺんに送受できるだけの帯域幅を実現する光ファイバーケーブルが直通で引かれているとしても、
  200,000km/sごときでは50msもかかってしまう！
- どうやら、`dev.to`に対するリクエストに応答したWebサーバは、**NYではない、もっと東京に近い場所にあるらしい**
- 当然といえば当然だが、インターネットとその上に成り立つWebは、クライアントとサーバ、**どちらも物理的な場所に束縛されない**
    - アメリカのサービスでも、日本国内にWebサーバを置いて何ら問題ない
    - それどころか、**アメリカのクライアントはアメリカのWebサーバに応答させ、日本のクライアントは日本のWebサーバに応答させたって良い**

---

> - **さっきの画像と中身が違う**

- 単純に考えれば、内容がWebサーバ側で更新されたと推測できる
- 一方、既出の内容を思い出すと、別の実現方法も考えられる

    > - あるいは実体としてのファイルはWebサーバの記憶装置には存在せず、要求されたときにプログラムが都度生成しているのかもしれない

- あるURLが、提供者側で明示的に更新されない限り、「誰に対しても」「全く同じ内容を」「返し続ける」場合、これを **静的; static** な内容という
- 反対に、「クライアントによって」あるいは「タイミングによって」、「異なる内容を返す」場合、 **動的; dynamic** であるという
    - これらの言葉には注意が必要で、組み合わせもありうるし、「変化」がどのレイヤで行われているかも場合によって異なる
    - たとえば、リクエスト送信者によって送信内容をWebサーバ側で変えるようなケースもあれば、
      JavaScriptを利用してクライアント側で内容を変動させることもあり、どちらも「動的」と言いうる

---

- `dev.to`は「爆速化」のためにあらゆる策を講じている。前項の、

    > - それどころか、**アメリカのクライアントはアメリカのWebサーバに応答させ、日本のクライアントは日本のWebサーバに応答させたって良い**

    - この手法とも組み合わせて、「どうしても遅くなる部分をユーザに気づかせない(**非同期** に処理する)」であったり、
      「一度生成した動的な内容をある程度の期間使いまわす(**キャッシュ; cache** する)」であったりといった工夫を行う

---

- いわゆる **アプリケーションサーバ; Application Server** や **APIサーバ; API Server** と呼ばれるWebサーバの類型は、
  静的なファイル内容の送信だけではなく、以下のような能力を持つWebサーバと言える
    - 動的なコンテンツ生成
    - リクエストに付随して、送信コンテンツの計算以外にも副次的な処理
        - リクエスト内容をもとに、サーバ側に何らかのデータを保存
        - メールを送信
        - 別のアプリケーションサーバに更にリクエストを送って連携した機能を実現
        - サーバ側に存在する大量のデータに対する **バッチ; Batch** 処理などの **非同期** 処理を開始
        - これらを **副作用; Side-effect** と言ったりする
- **API; Application Programming Interface** はソフトウェア開発のあらゆるレイヤで登場する語

---

- 動的なコンテンツ生成をする、ということは、
  「**リクエストの内容を元に、プログラムで定めた処理を行って、送信すべき内容を計算する**」ことにほかならない
- 従って、
    - そのサービスの開発者が、実現したい機能内容を自分たちでプログラムとして表現し、
    - かつ、そのプログラムがHTTP要求に対し正しい応答を行うことができる必要がある
        - ＝クライアントから見る限りにおいて、Apache HTTP Serverなどの既存製品と同等の要求処理をこなす
        - このように、特定のプロトコルに則った要求処理・応答ができることを指して、俗に **喋る** と言ったりする
- 当然ながら、**InternetとWebのプロトコルスタックをすべて自前で実装するのは骨が折れる**
    - ぼくにはとてもできない
- そこで、それらの大部分を**隠蔽**し、開発者は本質的に実現したい機能だけ(「ビジネスロジック」と呼ばれたりする)をプログラムとして実装すれば、
  あとは組み合わせて実行するだけでWebサーバとして振る舞うようになる、という **フレームワーク; Framework** が多数存在する

---

## 「動的生成」

- 一口に「動的」といっても、HTTPリクエストに対し、何を起因としてコンテンツを変動させるかは様々
    - 時刻
    - 送信者(IP)
    - 送信者(**認証; Authentication** 情報)
    - 送信者に認められた閲覧・操作の**権限; Privilege**
    - 付加情報
        - HTTPでは、URL以外にも **ヘッダ; header** や **body** (文脈によっては payload とも)を付与できる
        - URLの一部として、リクエストごとに変動しうる情報を付与することもある(**クエリ; query parameter/query string** や **fragment/hash**)
    - 履歴
    - コンテンツの有効期限
    - etc...

---

- 静的なファイルを送信するWebサーバでも、認証情報の有無による閲覧制限など、実行時設定だけで実現できることも多い
    - **Basic認証** を用いた閲覧制限など。明確な定義が規定・共有されており、様々な製品で最初から実装済み
    - このような手法の適用は、動的生成とはまず言わない
- 動的生成という場合は:
    - コンテンツをそのまま保存(**永続化; persist**)したファイル実体がWebサーバ上にあるわけではなく、
    - **テンプレート(ひな型; Template)** システムを用いて、表示内容の一部が変動する文書をひな型をもとに生成したり、
    - 後述する **データベース** に保存されているデータを、特定形式に **シリアライズ; serialize** したりして、
        - Serialize にはあまり良い訳語がない。 **変換; convert** といっても良いが、
          「何らかの構造化されたデータを送信・保管のために都合の良い(多くは **machine-readable** な)形式に変換する」
          というニュアンスでよく使われる
    - リクエストごとに送信するデータを構築する方式を指す
- この辺は筆者の肌感で書いている。もっとちゃんとした定義があるかもしれない

---

## アプリケーションサーバの構成要素

- 本文書では大枠で既知としているHTTPには、リクエスト時に指定する`GET/POST/PUT/DELETE`などの
  **Method** (**動詞; Verb** と呼ぶことも)が定義されている
    - それぞれが「どのような要求を意味するか」
      「サーバは要求に対し何をすべき(**SHOULD**)か、あるいは何をしてはいけない(**MUST NOT**)か」がRFCに規定されている
        - 行儀の良い、正しく実装されたWebサーバアプリケーションやフレームワークは、こういった規定を遵守していることが多い
        - 開発者が自由に実装できるアプリケーションサーバも、当然RFCを遵守するほうが都合の良いことが多い
        - **演習2**: 演習1で特定したRFCのどこかに、上記のような Method の定義がある。探して読んでみよう

---

- アプリケーションサーバも、こうしたHTTPの枠組みの上で、機能実現を目指すことになる
    - もちろん、HTTP以外のプロトコルをベースにすることもある
    - TCP上に直接、独自のプロトコルを定義することもある(オンラインゲームなどでは日常的)
    - "Web"アプリケーションサーバといった場合には、暗黙にHTTPをベースにしたプロトコルを用いるアプリケーションサーバといった印象だが、
      このあたりの単語はそれほど明確な使い分けがなされているわけでもない
- ただし、HTTPの規定は一般的な内容を定めるに過ぎないので、
  アプリケーション独自の要請に基づき、 **リクエストの形式をアプリケーションサーバごとに定める** 必要がある

---

- 応答可能なMethodとURLの形式
    - 例) `GET /items`, `POST /comments`, `GET /users/:user_id`
        - 大抵の場合、アプリケーションサーバの **ホスト名; hostname**(例えば`dev.to`)は別で定義済みであることが多いので、
          上記のようにパス部分で定義することが多い(フレームワークを使った実装の際に、あるいは **API Documentation** 上で)
        - 上記の`:user_id`という部分は、URLの中で変動しうる部分(いわば変数)を示す
            - この書き方は一部のフレームワークで実際にコード内で使用されるほか、 API Documentation にも表れる
            - ほかには、`/users/<user_id>`, `/users/${user_id}`などと書き表すこともある

---

- 利用するheaderの種類、期待する値の形式
    - 例) `Authorization` - サーバに対して **認証** 済みであることを示す何らかの文字列(**トークン; Token**)を伝えるのによく用いられる
    - このような、特別な意味を持つとされていて、用途・形式がRFCで標準化済みのheaderも多い
- body/queryを利用するか、するならば期待する値の形式
    - 例) 「Bodyは **JSON (JavaScript Object Notation)** 形式で、
      `"password"`フィールドに、文字列で、認証のためのパスワードを格納していること」など
    - Bodyの中身がどのような形式であるかを示す特別なheaderとして`Content-Type`があり、
      ここに **MIME Type** で正しく形式を表明しておくことで、クラサバ間で誤解なく大きなデータの交換ができる
        - これも「標準化されたheader」の一つ

---

## API設計の流儀

- アプリケーションサーバ開発の大まかな流れとは:
    - リクエスト形式を規定し、
        - これを **API仕様; API specification** と呼ぶことが多い
    - 規定したリクエストに対応する機能を実現しつつ、
    - 規定したとおりの応答を行うよう、プログラムを実装する
- この際、どのようなAPI仕様とするか、**全くオリジナルに考えるのは苦労が多い**。
    - 何らかの指針があったほうが開発者としては嬉しいし、
    - 利用者側としても異なるサービス間で大まかな指針が共通していれば、理解が早い
    - コードの共有を図れる可能性も上がる

---

- いくつかのAPI設計パターンが提唱されており、用途や適正に合わせて利用される
- **RESTful**
    - 「リソースに対する操作」を、
    - 「HTTPで定義済みのMethodを活用して表現」する、
    - 「**ステートレス; Stateless**」(後述)なプロトコル設計思想
    - 厳密なものから「なんちゃって」まで含めると、非常に幅広くWeb APIで利用されている
        - Bodyの形式(**IDL; Interface Description Language**)としては **XML** や **JSON** を使うことが多い
    - 問題点もある
        - 表現力が限定的。「リソース」と「それに対する操作」では表現しにくい処理も多くある
        - Bodyの形式を厳密に定義するための **スキーマ言語; Schema Language** とセットになっていない
            - IDLごとに一応存在するが、使いにくかったり、表現力が低かったりすることもある
            - 結果、API spec/documentationの形式がバラバラになったり、コード自動生成がしづらかったり
        - 複数の処理を組み合わせるための統一的な手法がない
            - 複数のリソースへの処理を同時に行いたい場合に、複数のHTTPリクエストの発行が必要になりがち

---

- **grpc**
    - **HTTP 2.0** 上で実現するプロトコル
        - HTTP 2.0では一つのTCPコネクションを維持した上で、その中で複数のHTTPリクエストを往復させられる
    - IDLとして **Protocol Buffer (protobuf)** を用いる。 **スキーマ言語を同梱**
    - **RPC; Remote Procedure Call** は、その名の通り遠隔サーバ上に命令を送ること、及びその形式
        - RPCと名乗るプロトコルの場合:
            - アプリケーションサーバ側で実行されるべき処理内容をより具体的に表現したリクエスト形式であることが多い
            - 別のプロトコルを、そのRPCのリクエストを転送するための手段としてだけ用いる(**transport protocol**)
                - 例) grpcでは、HTTP 2.0をtransport protocolとして利用するが、
                  一旦接続が確立されたら、処理内容を決めるのはあくまでprotobufで記述されたBodyの中身のみ
                - 転送経路を確立したあとは、利用するのはbodyだけなので、URLはただ一つであることが多い
                - Transport protocolは交換可能であることも多い。HTTP 1.1/2.0, **Websocket**, Raw TCP
    - じわじわと利用が広がっている

---

- **GraphQL**
    - Query と Mutation という枠組みでリソースに対する操作を表現する方式
    - RESTfulの抱えるいくつかの問題に対するアンサーとなっており、
        - 複数の処理の組み合わせ記述、
        - スキーマ言語、
        - 取得する情報の絞込み、などの特長を備える
    - 多くはHTTP 1.1上で実現されるが、こちらもRPC的なインターフェイス(bodyですべてを表現)であるため、
      原理的にはtransport protocolはなんでも良い
    - ところどころ使われてはいる

---

## 状態、ステート、State

- という言葉がすでに出てきている
- **ステートフル; Stateful** なプロトコルは、クライアントとサーバの間で何らかの順序・手順に基づいた情報交換がなされ、
  全体として正しく処理が実施されるかは、**それまでの処理の結果(＝状態)に依存する**
    - たとえば、TCPはステートフル
- **ステートレス** なプロトコルは、各リクエストがそれぞれ独立しており、それまでの処理の結果によらない
    - HTTPはステートレス

---

- HTTPに乗っかっている、アプリケーション(API)レイヤでは:
    - 大抵の場合いわゆる「ログイン状態」のような、
        - 本人認証が完了しており、
        - 有効期限内の認証トークンが発行されている期間(**セッション; session**)を意味する概念がある
    - セッション制御は、どうあがいても本質的には **ステートフル** である
        - サーバ側かクライアント側、どちらかに状態を必要とする。さもなければ毎リクエスト個別に認証しなければならない
    - それ以外にもアプリケーションは **状態の宝庫** である
        - **電子商取引; E-Commerce** システムでは、「買い物かご」や「口座」といった概念は頻出

---

- RESTfulの指針の一つに「ステートレス」があるものの、これをうまく捉えるのははっきり言って難しい
    - 個人的に新人の頃の理解の助けになったのは以下のブログ記事
        - [技術/HTTP/REST設計思想の "Stateless" との付き合い方](https://www.glamenv-septzen.net/view/1350)
    - 「**長期的に永続化されるリソースの状態**」と、
      「**短期的にクラサバ間で共有するアプリケーションの状態**」を分けて考える方が良い
        - RESTfulがAPI設計によって分離しようとする「状態」はどちらかというと後者
    - この辺は実際に製品開発を行いながら感覚を培って欲しい
- ついでなので言葉だけ挙げておくと、 **冪等性; idempotency** という概念もAPI設計において重要になる

---

## 「リソース」の棲処

- ここまでを振り返ると、
    - Webサーバの一類型として、HTTPリクエストを入力に、プログラムに基づいた処理を行い、
      動的なコンテンツを生成したりするのがアプリケーションサーバ
    - APIの設計には、ベースとするプロトコルの違いや、RESTfulなどのパターンなど、複数の流儀がある
    - 「状態」や、「リソース」といった概念が登場する
- 「**リソース**」と無邪気に言い放ってきたが、リソースってなんだろうか

---

- 古典的な静的ファイルを送信するWebサーバに立ち戻ると、リソース≒ファイルだった
- しかしアプリケーションサーバでは、必ずしもファイルとリソースは1対1対応しない
- Unix系でもWindowsでも、 **ファイルシステム; file system** は、
    - ツリー状のデータ構造
    - 一意にファイルを特定する **パス; path**
    - 作成時刻、更新時刻、バイトサイズなどのメタデータ
    - 中身のデータの保持
- といった特徴は共通で、それ自体汎用的で欠かせない体系なのだが、
  Webアプリケーションを実装するにあたってはそれだけでは足りないことが多い

---

- リソースとして保存したい事項は様々あるので、データの中身を **構造化** したい
    - 一つ一つのデータ点が、特定の値の組み合わせを持つよう規定できる
        - たとえば、サービスのユーザ情報だったら`id, email, family_name, given_name`など
    - 構造にそぐわないデータ入力は拒否するなど、検証・強制できる
        - 生のファイルシステムにおいては、ファイルは任意のデータ
- 構造化されたデータの中身をもとに、 **問い合わせ, クエリ; query** あるいは **検索; search** したい
    - 任意のファイル群相手では、求める内容を含むものを一意に見つけ出すことは難しい
        - バイナリファイルであれば、内部構造を解釈する方法を知らなければならない
        - テキストファイルでも、 **encoding** によっては読み出し方が異なる
        - ファイルは **暗号化** されていてそのままでは読めないかもしれない
- クエリや検索が **時間的・空間的に高効率(time and spatial efficiency)** で行えるようなシステムであって欲しい
    - 「目的とする文字列を含む行をテキストファイルから見つけ出す」といった原始的な操作なら様々な方法がある(例えば **grep**)
        - が、単なるgrepなどは **線形時間; linear time** で動く
        - つまりファイル数(行数)が増えるごとに、検索完了までにかかる時間は線形で伸びる
    - ついでにqueryはできたら統一的な文法で簡単に書きたいし、なんなら複雑な条件を組み合わせたりもしたい

---

## データベース

- まさに **データベース; database (DB)** の必要とされる世界
    - このような要求は**Webの誕生以前からあり**、豊富な知見、研究、技術の蓄積がある
    - 豊富であるということは当然取っ掛かりがつかみにくい世界でもある
- 多くのアプリケーションサーバは、何処かにあるリソースを組み合わせて機能を実現するが、DBはその主たる棲処の一つ
- DB管理システム(**database management system; DBMS**)も様々存在するが、おおよその共通項としては、
    - ファイルシステム上で動作し、最終的にデータ実体はファイルとして保存する
    - ただし、保存(**永続化**)する際のファイル形式と、読み出されるときの形式とは必ずしも対応しない。
      そこはDBMSの実装が知っていればいい部分で、利用者側からは**隠蔽**されている
        - **Database engine/Storage engine**の担当箇所。そのDBMSの性能と密接な関係を持つ

---

- アプリケーションが取り扱うリソースをどのように表現し、それをどのように(物理的・論理的に)DBに格納するかは長らく研究されてきた
- **関係(リレーショナル)データモデル; Relational data model** と、
  それに対応した **関係(リレーショナル)データベース; Relational database management system, RDBMS** が非常に広範に使用されている
    - RDBMSは、「ある程度」標準化された **SQL** という専用言語(**Domain Specific Language; DSL**)を利用してデータの操作やクエリを行う
        - 「ある程度」というのがキモで、標準化団体による規格は策定されているが、
          対応状況がまちまちだったり、製品ごとの独自拡張がたくさんあったりする
    - 特定の空間ないし集合(**テーブル; table**)に属するデータ(**レコード; record**)は、
      特定の値の組み合わせを持つよう強制力のある規定ができる(**スキーマ; Schema**)
    - 製品によっては、「**一連の操作がすべて成功するか、(何らかの問題があった場合には)まるごと一切なかったことにできる**」
      というall-or-nothingな操作を行うことができるものがある
        - これを **トランザクション; transaction** 処理という
        - Transaction処理の満たすべき特性を **ACID(Atomicity, Consistency, Isolation, Durability)** 特性という
        - たとえば **電子商取引; E-Commerce** でよくある例だと、
          「ユーザの保有ポイントを消費し、商品を利用可能にする」といった処理は不可分としたい
            - 「ポイントだけ減って、商品が利用できない」といった **部分的失敗; partial failure** はユーザ体験を著しく損なう
    - 有名なRDBMS: **MySQL**, **PostgresSQL**, **Oracle Database** など

---

- 一方で、RDBMSだけでは近年のWebアプリケーションの要求に対して最適な性能・信頼性を担保できないケースが近年頻出した
- そこで現れてきたのが **NoSQL; Not only SQL** と呼ばれるデータベースの類型
    - RDBMSの既存製品が持っていた特徴の一部を諦める・弱めることを受け容れつつ、
    - 別の部分の性能・信頼性を向上させるアプローチを取る
- **Key-Value Store; KVS**
    - 「キーに対する値」、という単純なペアを基礎としてデータを保持するもの
    - データの複雑な構造化や、それに対するSQLを用いた複雑なクエリなどは(ある程度)諦める代わりに高速で、
      **分散; distributed** 処理の適用がし易い
    - データを永続化せず、メモリ内だけで実現するものもある
    - 有名なKVS: **Amazon Dynamo**, **RiakKV**, **Redis**(in-memory) など

---

- **ドキュメント指向DB; Document-oriented database**
    - **JSON**などの「ドキュメント」形式で、構造化されているが、固定のスキーマに縛られないデータを投入できる
    - 一つのドキュメント内でデータの階層化なども行える
    - SQLほど標準化はされていないが、それぞれの製品ごとにクエリのための文法を持つことが多い
    - 完全なACIDトランザクションをサポートしないものが多いが、より弱い仮定の機能や保証を持つことはある
        - **結果整合性; eventual consistency**
        - **楽観ロック; optimistic lock/optimistic concurrency control**
    - 有名なドキュメント指向DB: **Amazon DynamoDB**, **MongoDB**, **CouchDB**, **MarkLogic** など
    - **全文検索エンジン; Full-text search engine** もドキュメント指向DBの一種とみなすこともある
- **列指向DB; Columnar database**
- **グラフDB; Graph database**

---

## インデックス

- ところで、RDBMSにしろNoSQLにしろ、目的とするデータの読み出しに**線形時間**(O(N))かかったのでは意味がない
    - たとえば、ユーザIDを元にしてそのユーザの情報を取得したいときに、
      ユーザが合計100万人いるなら最悪ケースで100万件総なめしないと対象ユーザが見つからない、などというシステムは使えない
- ほとんどのDBは、データの取り出しを線形時間未満で行うために **インデックス; index** という補助的なデータ空間を持つ
    - 「データが持つ項目(属性)の一つ(**index key**)」から、
      「そのデータが永続化されている物理的な空間位置」を高速に解決できる、まさに「索引」
    - **平衡木; Balanced tree** の一種(**B-tree** や **B+ tree** など)や
      **ハッシュテーブル; Hash table** を使って実装される
        - 例えば[MongoDBはB-treeを使っている](https://docs.mongodb.com/manual/indexes/index.html#id2)
    - **O(log(N))** で目的データを取得・更新・削除できるものが多い
    - ある項目に同じ値を持つデータはその集合内に1つしか存在できない(**一意性; uniqueness**)といった制約も、
      その項目をkeyとするindexを事前に構築して利用することで達成する
- DBを「正しく」「効率的に」使うには**インデックスの存在を意識しておくのが肝心**
    - アプリケーションで取り扱うデータ構造を設計する際も、DBを効率良く使うことを念頭に置きながら考える

---

## 「キャッシュ」、そして「分散」

- 今一度`dev.to`のことを思い出してみよう
    1. 生成されたコンテンツを一定期間使いまわす
        - **キャッシュ; cache**
        - 広い意味でのキャッシュは様々なレイヤで行われ、場所、文脈、用途によって意味するものも変わる
        - WebサーバがHTTPリクエストに対して応答する部分よりも外側に限れば、
          一度生成・取得されたコンテンツを一定期間使いまわすこと
            - 最もクライアントに近い部分ではWebブラウザ内部で、最も遠い部分ではサーバの内部実装で行われる
    2. クライアントに物理的に近い場所に存在するサーバに処理を担当させる
        - **Content Delivery Network, CDN**
            - 正式な供給源(**origin**)が発行したコンテンツを、一定の規則に基づいてキャッシュした上で、
              物理的に近傍に位置するクライアントからの取得要求にoriginに代わって応答する
        - **エッジコンピューティング; edge computing**
            - CDNと比較してより複雑な処理や、ともすれば大量のデータを中央サーバに送信する必要があるような処理を、
              クライアントの物理的近傍のサーバで済ませる。計算資源の分散、通信帯域の削減を可能にする
    3. 同等の処理を実行できるサーバが同時に複数存在する

---

- 最後の「同時に複数存在」するサーバだが、レイヤによって能力、前提が異なる
    - 例えばCDNも、クライアントに物理的に近い**エッジロケーション; edge location**には責務を担当可能なサーバは複数ある
    - が、CDNの場合、エッジサーバ内部に必要なデータが存在しなければ、
      originにリクエストを転送して一次情報の生成を要求し、それをキャッシュすれば良い
- 一方、originに該当するアプリケーションサーバ(群)はどうか
    - ここが正式な一次処理を完遂できなければアプリケーション全体が立ち行かなくなる
    - とはいえ、ただ1台のアプリケーションサーバや、ただ1台のDBだけでどれだけのユーザを捌けるだろうか
        - 当然マシン性能にもよるが、2000年代前半には**C10k(10,000 connections/clients)問題**として議論された
            - 1台のマシン上で稼働するサーバで捌けるユーザ数には限界があるし、
            - マシンの単体性能を上げるのにも限界があるし、
            - どんなに性能が上がっても、急な負荷上昇やハードウェアの故障からは逃れられない
- 第一次的な、基幹となる処理担当部分にも、処理の **分散; distribution** や、
  ハードウェア的・ソフトウェア的 **冗長化; redundancy** による **可用性; availability** の向上が求められ始める

---

- **RESTful** で唱えられている **ステートレス** の理解が難しい、という話があったが、
  この「分散の必要性」という文脈に乗ると少し納得がいくかもしれない
    - 単一のサーバであればステートフルでも構わなかったのだが、複数のサーバで処理を分散担当するとなると、
      「**直前に担当していたサーバとクライアントとの間で保持していた状態が、別のサーバには共有されていない**」
      という問題が当然生じてきてしまう
    - これをどうにかするためのアプローチとして、
        - そもそもクラサバ間で逐一状態共有するようなことを避けて、処理の分散を容易にする
            - RESTfulが重要視するところの **ステートレス指向**
        - 状態を別の(高速に読み出しできる)DBなどに保存しておいて、どのアプリケーションサーバからも参照できるようにする
            - **In-memory KVS** などを利用する

---

- かくしてWebアプリケーションのサーバサイド開発が、不可避的に **分散システム; distributed system** 開発となる時代に
    - これ自体もWebの登場以前から研究されてきた歴史がある。多くの技術・概念が登場し、一筋縄ではいかない
    - **負荷分散; load-balancing**
        - 同様の責務を果たせるサーバが複数台存在するとき、それぞれの負荷が一様になるよう、
          クライアントからのリクエストを適切に振り分けなければならない
    - **合意形成アルゴリズム; consensus algorithms**
        - 複数のマシンが協働して(**クラスタ; cluster**)リソースの永続化とそれに対する操作を可能にするようなDBMSでは、
          読み、書き、あるいはその両方を複数のマシンが担当できる、
          または担当するマシンへの要求転送を行える、といった必要が出てくる
        - 保管しているリソースそのものや、クラスタの状態理解がマシン間で **分岐; diverge** してしまうとおかしなことになる
        - クラスタに参加しているマシンは、最新の状態を、できるだけタイムラグなく、共有できなければならない
    - ほかにもどんどん出てくるだろう

---

## 結び: 辿り来て、未だ山麓

- 以上、サーバ開発分野に関する頭出しを行った
- かなり盛りだくさんになってしまったし、具体例もそれほどない文書なので、各々で掘り下げてほしい
- このあと実際にサーバサイドのコードを書いてみる研修時間が長めに取られているので、その中で適宜振り返ろう
- 何度も繰り返すが、「**調べられること**」こそが第一の技術
- サーバに限らず、どの分野も研修の数週間ではとても網羅しきれない世界。未だ山麓です

---

## 付録: 漏れた話題

- 業務や、このあとの研修で触れることもあるはず。適宜調べよう
- アプリケーションサーバ設計・実装におけるパターンや思想
    - この辺は使うフレームワークの最新の流儀をさらいながら学んでいくほうが良いと思うので含めなかった
    - キーワードは、 **Model-View-Controller; MVC**, **Layered Architecture**, **Domain-driven Design; DDD** など
        - スマートフォンアプリやWebアプリ(ここでは、ブラウザで動くJavaScriptなどで実装されたクライアントアプリケーションの意)の
          設計・実装の思想と共通する部分もあれば違う部分もあるので注意が必要
- 「サーバからクライアントに」情報を送信する技術
    - リソースの更新など、何らかの情報を **リアルタイム; realtime** にクライアントに通知したい状況
    - TCPソケットを維持した上で、 **双方向通信** するなど。 cf. **Websocket**

---

- **マイクロサービス; Micro-service** アーキテクチャ
    - 対義語: **モノリシック; Monolithic** アーキテクチャ
    - 特定の用途に特化したアプリケーションサーバ等を別々に構築し、それらを組み合わせてサーバサイドシステムの全体を構成する手法
    - 部分的な性能調整や更新の適用がし易い、部分的な故障が全体に波及しない、 **コンテナ技術** との相性が良い、などの利点
- 複数構成要素からなるサーバシステムでの**Pull**型構造と**Push**型構造
    - Pull型は「クライアントがリソースを取りに行く」、Push型は「リソースをクライアントに押し付ける」イメージ
    - リソース源とリソース利用者との数的関係にもよるが、いずれの場合も「**数的に少ない側に負荷がかかる**」ことが多い
    - 例) 「ログ集積サーバ」のような要素を導入することは多いが、ここに対してログを送りつける(pushする)他のサーバが多い場合、
      ログ集積サーバに高負荷がかかる。最悪ケースではシステム全体が不安定になる
        - cf. **単一故障点; Single Point of Failure, SPOF**

---

## 付録: 演習振り返り

- 演習1: HTTP 1.1のRFC
    - 現在有効なのは以下:
        1. "Message Syntax and Routing" [RFC7230]
        2. "Semantics and Content" [RFC7231]
        3. "Conditional Requests" [RFC7232]
        4. "Range Requests" [RFC7233]
        5. "Caching" [RFC7234]
        6. "Authentication" [RFC7235]
    - 先頭にあたる[RFC7230]にサマリがあり、他の関連文書との関係も書かれている
- 演習2: HTTP Methods
    - [RFC7231]の[Section 4](https://tools.ietf.org/html/rfc7231#section-4)にまとまっている
    - `PATCH` methodだけは[RFC5789](https://tools.ietf.org/html/rfc5789)に定義されている

[RFC7230]: https://tools.ietf.org/html/rfc7230
[RFC7231]: https://tools.ietf.org/html/rfc7231
[RFC7232]: https://tools.ietf.org/html/rfc7232
[RFC7233]: https://tools.ietf.org/html/rfc7233
[RFC7234]: https://tools.ietf.org/html/rfc7234
[RFC7235]: https://tools.ietf.org/html/rfc7235
