# サーバ開発基礎

---

## まえがき

- この文書は:
    - [@access-company]の新卒技術研修、座学資料
    - 2018年度作成
    - 文責は[@ymtszw]
    - 1時間程度を想定
    - 「サーバ開発基礎」のくくりである
    - といってもあまり系統立てられた「授業」はしたこともないしできないので、フワッフワした講義になるであろう
    - そもそも筆者個人が、「サーバ開発」に関して系統立った教育を受けたことはない
        - 筆者自身の新卒研修では、サーバサイドは Rails チュートリアルベースだったような記憶があるが、かなり前なので怪しい

[@access-company]: https://github.com/access-company
[@ymtszw]: https://github.com/ymtszw

---

## 前提知識: 「はじめにWebありき」

- 本文書では、"Web (World Wide Web; WWW)"は、大枠を既知とする
    - Web を実現している数々の要素技術について、概略として想像が及ぶこと
    - 権威ある論文や RFC, 教科書などに基づいた系統的な教育を受けていなくても、Web がどういったものかについて一般的な知識があれば今は充分
    - 以下のキーワードを聞いたことがあり、 **調べれば正式な定義や最新のコンセンサスに辿り着ける** と自分が思うならば問題なし
        - HTTP
        - DNS
        - URI / URL
        - HTML
- クライアント・サーバ(Client and Server)モデルの概念も既知とする

---

## 暗黙の前提技術: 「調べられること」

- 本文書は網羅的な教科書となることを目指さない。できねぇし
- 従って文章中にわからないことが出てきたら **自分で調べられること** を前提とする
    - 「そのときすぐ」でなくて良い。いずれ思い出して気になったとき、でも良い。脳内の「知らないこと領域」に追加すればよい
    - この領域は面白いデータ構造をしている。 cf. Algorithms and Data Structures; アルゴリズムとデータ構造
        - 追加した順に取り出せる(**Queue**)とは限らない。追加したのと逆順に取り出せる(**Stack**)とも限らない
        - 「重要かどうか」など、何らかの指標によって順序付けられている(**Heap**)わけでもない
        - 追加したが二度と取り出されないことが頻繁にあり得る
        - それどころか **追加したのに知らぬ間に消滅することもある**

---

- なにごとも、全て完璧に定義や公理まで遡って理解できなくても良い
    - そのとき興味のある部分までとりあえず掘り下げる
    - 過程で必ず新たな新事項がでてくるはずだが、時間があるならそこも掘ればいいし、なければ **遅延評価(Lazy evaluation)** する
        - 「知らないこと領域」にやはり突っ込んでおき、同じプロセスを辿らせる
        - 「そう言えば前もこの単語わからなかったな」という「気づき」はいわば **duplicated insert** である
            - とはいえ厳密な **一意性(uniqueness)** が存在する **集合(Set)** なのかはよくわからない
            - なんにせよ別々の機会に渡って複数回疑問を抱くというのは自分にとって重要である可能性と相関するはず
- そのようにして順に「知らないこと」を調べていくのが **何よりも重要な技術**
    - ちなみにいざ調べることが必要になったときにも「戦略」がありうる
        - 当座の対象について、大まかな理解を優先するなら **幅優先(Breadth-first)探索** する
        - どんどん掘り下げたい気分なら **深さ優先(Depth-first)探索** する
            - 深夜にやるのがオススメである。会社には遅刻する

---

- 本文書が伝えたいことのうち、 **実に7割くらいがこの「調べられること」の重要さ** である
    - そもそも「サーバ開発の基礎」だって、皆が個別に調べられるならば講義しなくても良いのだ
        - **並列(Parallel)** かつ **非同期(Asynchronous)** な形態である
        - 逆に複数人がこの資料を同時に読み進めながら座学講義するのは **同期的(Synchronous)** な処理である
            - 進捗は全員同じペースとなる
            - 全員の理解度を都度確認しながら進めるような場合は、最も理解に手こずっている人の速度に全体が合わせることにもなる
            - 一方で、よくわからなかった部分は「あとで調べればいいよ」などといって先に進むかも知れない
                - これは「**時間のかかる処理単位を非同期的実行に切り替える**」行為である。"Asynchronous job dispatch"などという
                - もしもこの「あとで」が、「必要になったときに改めて」などと読み替えられたならば、 **遅延評価** にも該当する

---

- はじめはどんな分野でも知らないことのほうが多いので、「何から手を付けていいかわからない」状態になりがち
    - 索引(**index**)なしで辞書を読むようなもの。たまに辞書を最初から最後まで読む輩とかもいるが。。。
- 本文書は、サーバ開発に関して「この辺が頻出/基礎/重要」「この辺がキーワード」「この辺が面白い」などを、
  ちょっとしたストーリーに沿って挙げていく。いわば分厚い辞書に付箋をうつことを目的とする
- 従って、 **この文書を読みつつ、ポイントとなりそうな事柄を自分で調べて、枝葉を広げるように進める** のが使い方となる
- 既に気づいているかも知れないが、そのためにいくつか仕掛けがある

---

- **太字** になっていたり、対応する英単語が併記されていたりするのは、
  筆者が重要だと思っているポイントや、「気になったら調べて欲しい事柄」である
    - 特に、固有名詞っぽいものや専門用語っぽいものは興味を持って欲しい
- リンクはあえて、ほとんどつけていない。(片っ端から付けるのが面倒だったというのもあるが、)
  **権威のありそうな情報源を特定する** のはこれもまた技術であり、練習してみてほしいからだ
    - 「一次情報源」の特定

---

## 「調べ方」の手引き

- Web関連の技術要素で広範に利用されているものであれば、
  IETF が中心となって業界関係者からなるグループで議論した上で、 **RFC(Request For Comment)** としてまとめてあることが多い
    - 厳正な議論とレビューのプロセスを経ており、権威ある情報源であることが多い
        - このことが保証するのは説明・定義として誤謬がなく信頼できるという点であって、
          その内容が現代の実務状況に照らして「使いやすい」「ベストな」ものとは限らないのは了解しておくこと
    - 例) [RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax](https://tools.ietf.org/html/rfc3986)
    - 読むときは、
        - "Status"や、
        - "Obsoletes: ..." 「〜を廃止する」(廃止して置き換える)や、
        - "Updates: ..." 「〜を更新する」に注意する
    - その文書が現在どのような扱いであるのか確認してから読む。既に廃止されたバージョンかもしれない
- ものによっては、その技術や概念は論文として発表されているかもしれない
    - **Google Scholar** はその検索のための極めて有用なサービス
    - 査読付き論文誌などに採択されていないものでも、 arXive で発表されているかも知れない

---

- 何らかのアプリケーションやフレームワークについて調べる際には、基本的にはそれらの開発元が提供している文書が確実である
    - ニュアンスとしては以下のような感じ:
        - "Guide": 実際に使用する方法を順序立てて流れとして説明する文書
        - "Reference": アプリケーションのコマンドやAPIなど、一つ一つの細かな仕様をまとめた文書
        - "Documentation": Guideに近いことが多いが、場合によってはReferenceじみた様相のものもある
- ある分野に関連する語彙や概念についてまとめて一度に調べたいのであれば、書籍や解説サイトが有効
    - 書籍にはレビューがつきものなので、良し悪しを判定してから買うのが容易。先輩に聞くのも良い
        - 特に、既にある程度枯れた技術で、定番の解説書がある、といったケースではそれを読むのが手っ取り早い
    - 解説サイト・ブログなどはまさに玉石混淆なので油断ならない
        - 一般に、権威ある情報源や、関連する文書へのリンクを付与しつつ、
          その上で自分の言葉による噛み砕いた説明に落とし込もうとしている文書は、内容はともかく姿勢として信頼に値する
            - 要は書籍や論文と同じ
        - RFCや論文などへのリンク(参考文献リスト)がきちんとまとめられている限りにおいて、Wikipediaなどの記事も十分役立つ

---

- 大切なのは、どんな過程であれ **信頼できる情報に辿り着くための努力を惜しまない** こと
    - よくあるアンチパターン1: 「検索して最初にでてきたサイトを斜め読みしてわかった気になる」
    - よくあるアンチパターン2: 「StackOverflowからコピペ」
- 慣れてくれば、信頼できる情報に辿り着くための **ホップ数(hop count)** を減らせるようになる
    - RFCや公式ドキュメントなどの一次情報源を検索エンジン化して、ブラウザのアドレスバーからダイレクトに検索可能にする
    - その分野の代表的な研究者・開発者・開発企業をSNSでフォローしたり、ブログを購読したりして、最新情報を早く掴む

さて、ここまでが長い前置きで、ようやくサーバの話に入る

---

# [dev.to]を開いてみよう

[dev.to]: https://dev.to/

---

## [dev.to]

- 開発者向け情報投稿サービス
- 「表示が爆速」ということで話題になった
- The Practical Dev社によって開発運営されている
- 彼らは[**New York Cityを拠点としている**](https://dev.to/about)

---

## ブラウザの開発者ツールで見てみよう

- 別の講義でも紹介済みのはず
- macOSのChromeなら`Alt(Option) + Cmd + i`
    - 長い付き合いになるはずだ

![dev.to](devto.png)

(2018/05/01のある時刻に取得した画像)

---

## ここで復習: インターネットとWeb

- Webについて学習済みであるならば、以下のことは大体わかっているはず
- そもそも **インターネット; The Internet** とは、世界中にある計算機を有線あるいは無線の通信網で接続し、
  それぞれの間で意味のある情報を交換できるよう整備された系
- インターネットは様々なプロトコルの積み重ね(Protocol Stack)によって成り立つ
    - cf. **Internet Protocol Suite**, **TCP/IP**
- Webは、根本としては、 **URL** で表現される何らかの実体を、それを保管している計算機から取り寄せて閲覧するシステム
    - 対象となる実体は、多くの場合、人間が意味を理解できる文字からなる文書を、適切に **encode** したもの(データ、ファイル)
    - 画像・動画などは文字ではないかもしれないが、やはり人間が視覚的・聴覚的に理解できる情報を、適切に **encode** したもの
    - もちろん、人間を直接の対象読者とせず、プログラムの内部で計算機に使わせることだけを目的とするデータもありうる

---

## ここで復習: クラサバ, HTML, Webブラウザ

- 取り寄せようとする側を **クライアント; Client**, 設置場所の方を **サーバ; Server** とみなす
- **HTML** という形式で記述された文書を多様な用途に用いる
    - 多くの機能が規定されており、クライアントは **Webブラウザ** を使ってHTMLを閲覧することでこれらの機能を利用できる
        - 文書構造の定義(見出し、箇条書き、強調、装飾等)
        - 他の文書に対する言及、言及されている文書を簡単な操作で取得(**ハイパーリンク; Hyperlink**)
        - **CSS** と組み合わせることによる、文書構造を元にした視覚的な装飾表現の描画
- クライアントのWebブラウザ上で実行することで、閲覧時に文書内容を変動させたり、
  複雑な機能を実現したりするためのプログラムを配布することもある
    - 現代では、そのようなプログラムの多くは **JavaScript** で書かれる
    - 必然的に、多くのWebブラウザはHTML/CSSを解釈して文書を視覚的に描画する機構と同時に、
      JavaScriptプログラムを解釈して実行する機構も併せ持っている

---

## いわゆる「Webサーバ」

- クライアントからの **HTTP** 要求に基づいてデータを送出する機能をもつアプリケーションを **Webサーバ; Web Server**という
    - 代表的なのは **Apache HTTP Server**(**`httpd`**)
    - クラサバモデルにおける「サーバ」と同じ単語が使われている。
      このような文脈によって微妙に意味する内容が変わりうる語には常に注意が必要
    - Webサーバが稼働している計算機自体を指してWebサーバとも呼ぶ
- Webサーバは、最も基本的には、その計算機に装着された非揮発性記憶装置(たとえばSSD)上にあるファイルを読み出して、
  その内容をクライアントとの間で結ばれた **TCPソケット** 経由で送出する

---

## 再び[dev.to]

- ここまでさらったところで、改めてdev.toを閲覧した時の状況を見てみる
- (ざっと見方を口頭説明; あとから参照している場合は **Chrome devtools** で調べる)

![dev.to](devto2.png)

---

## 気づけること

- そもそも`dev.to`としか要求していない、つまり「ファイルパス」を与えていないにもかかわらず、意味のある情報が返ってきている
- `https://dev.to`という単一のURLを要求しただけなのに、大量のリクエストが付随して発生している
- **13msという速さ** で`dev.to`に対する冒頭のリクエストが完了している
- **さっきの画像と中身が違う**
- (ほかにも挙げてみよう)

---

> - そもそも`dev.to`としか要求していない、つまり「ファイルパス」を与えていないにもかかわらず、意味のある情報が返ってきている

- Webサーバは、必ずしもファイルを明示的に要求されて、それを返さなければならないというわけではない
    - `dev.to`部分(hostname)だけで「送出べき情報」が確定するのであれば、Webサーバはそれを送出する自由がある
    - この場合、`dev.to`とだけ要求された場合はサイトの「トップページ」を要求されたものとみなしているので、Webサーバはそれを送出した
        - 同じ慣習を採用しているWebサーバは多い
        - 逆に、古典的なファイルベースのサイトでは「トップページ」を意味するファイル実体として
          `index.html`などの"index"という名前を持つファイルを持っていることが多い
            - 「古典的」といっても、何も悪い意味ではない。この方式は現在も頻繁に使われる
    - `dev.to`と要求されたWebサーバは、
        - 「トップページ」の実体として存在するファイルを読み出して、その中身を送出しているのかもしれないし、
        - あるいは実体としてのファイルはWebサーバの記憶装置には存在せず、要求されたときにプログラムが都度生成しているのかもしれない
        - この2パターンはどちらもありうるが、 **クライアントから見た場合は一般に区別できない**
            - 結局の所クライアントに送り届けられるのはバイナリデータにすぎず、
              Webブラウザ等がそれを意味ある情報として解釈できる限りにおいては平等に扱われる

---

> - `https://dev.to`という単一のURLを要求しただけなのに、大量のリクエストが付随して発生している

- これはHTML文書、およびそれを解釈して描画する機能の一環として、
  「その文書自体とは別で存在する何らかのファイル」を追加で取得できる機能による
    - たとえばCSS, JS, 画像, 動画, 別のHTMLなど、様々なものを対象にできる
    - ("Type"列を眺めてみよう)

---

> - **13msという速さ** で`dev.to`に対する冒頭のリクエストが完了している

- ここで以下を思い出して欲しい:

    > - 彼らは[**New York Cityを拠点としている**](https://dev.to/about)

---

![Tokyo to NY](tokyo_ny.png)

- 約10,000km

---

- インターネットを成り立たせている通信回線網の根幹部分は光ファイバーケーブルからなる
- つまり1本のケーブル内での伝送速度は光速が上限となる(約300,000km/s)が、
  当然ながらケーブル内部で反射・屈折を繰り返すので、直線とはならない
    - 実用上は200,000km/s程度を上限とするらしい
- そして、極めて短い時間単位の光のon/offを元に、0と1からなるバイナリデータを表現する
    - このへんあまりに大雑把だが、本文書の対象とするレイヤではないので端折る

---

- 画像をよく見ると、`dev.to`が送出したデータのサイズは19.6KBとなっている
- 仮にNYのThe Practical Dev社までの間に、この約20KB(160KBits)を
  いっぺんに送受できるだけの帯域幅を実現する光ファイバーケーブルが引かれているとしても、
  200,000km/sごときでは50msもかかってしまう！
- どうやら、`dev.to`に対するリクエストに応答したWebサーバは、**NYではない、もっと東京に近い場所にあるらしい**
- 当然といえば当然だが、インターネットとその上に成り立つWebは、クライアントとサーバ、**どちらも物理的な場所に束縛されない**
    - アメリカのサービスでも、日本国内にWebサーバを置いて何ら問題ない
    - それどころか、**アメリカのクライアントはアメリカのWebサーバに応答させ、日本のクライアントは日本のWebサーバに応答させたって良い**

---

> - **さっきの画像と中身が違う**

- 単純に考えれば、内容がWebサーバ側で更新されたと推測できる
- 一方、既出の内容を思い出すと、別の実現方法も考えられる

    > - あるいは実体としてのファイルはWebサーバの記憶装置には存在せず、要求されたときにプログラムが都度生成しているのかもしれない

- あるURLが、提供者側で明示的に更新されない限り、「誰に対しても」「全く同じ内容を」「返し続ける」場合、これを **静的; static** な内容という
- 反対に、「クライアントによって」あるいは「タイミングによって」、「異なる内容を返す」場合、 **動的; dynamic** であるという
    - これらの言葉には注意が必要で、組み合わせもありうるし、「変化」がどのレイヤで行われているかも場合によって異なる
    - たとえば、リクエスト送信者によって送出内容をWebサーバ側で変えるようなケースもあれば、
      JavaScriptを利用してクライアント側で内容を変動させることもありうる
- `dev.to`は「爆速化」のためにあらゆる策を講じているので、前項の、

    > - それどころか、**アメリカのクライアントはアメリカのWebサーバに応答させ、日本のクライアントは日本のWebサーバに応答させたって良い**

    - この手法とも組み合わせて、静的・動的どちらのコンテンツも高速で送出しつつ、
      かつ、「どうしても遅くなる部分をユーザに気づかせない」であったり、「

---

- いわゆる **アプリケーションサーバ; Application Server** や **APIサーバ; API Server** と呼ばれるWebサーバの類型は、
  動的なコンテンツ生成を行うことを主眼としたWebサーバと言える
- 動的なコンテンツ生成をする、ということは、
  「**リクエストの内容を元に、プログラムで定めた処理を行って、送出すべき内容を計算する**」ことにほかならない
- 従って、
    - そのサービスの開発者が、実現したい機能内容を自分たちでプログラムとして表現し、
    - かつ、そのプログラムがHTTP要求に対し正しい応答を行うことができる必要がある
        - ＝クライアントから見る限りにおいて、Apache HTTP Serverなどの既存製品と同等の要求処理をこなす
- 当然ながら、**InternetとWebのプロトコルスタックをすべて自前で実装するのは骨が折れる**
    - ぼくにはとてもできない
- そこで、それらの大部分を**隠蔽**し、開発者は実現したい機能(「ビジネスロジック」と呼ばれることもある)だけをプログラムとして実装すれば、
  あとは組み合わせて実行するだけでWebサーバとして振る舞うようになる、という **フレームワーク; Framework** が多数存在する

---
