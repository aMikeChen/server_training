## 基礎: 文法等

- 文法のたぐいは以下を教科書としましょう
  - [Official Introduction](https://elixir-lang.org/getting-started/introduction.html)
  - [Elixir School](https://elixirschool.com/ja/lessons/basics/basics/) (日本語あり)
  - Elixir 標準ライブラリの[API References](https://hexdocs.pm/elixir/api-reference.html)
- 本文書では特に抑えてほしい部分だけ明示していきます
- サーバ実習ではまとまった文量の Elixir コードを書く時間が確保してあるので、
  **今の段階で文法をすべて把握できなくても OK**
- むしろツールチェーンの利用方法、全体的なワークフローを抑えてください

### パターンマッチ

- 他の言語にもありますが、Elixir は[**パターンマッチ**](https://elixirschool.com/ja/lessons/basics/pattern-matching/)と呼ばれる構文が強力です
- 一方で、他言語から移ってくるととにかく混乱をきたしやすい部分でもありますので、最初にここだけ触れておきます

---

- 例えば、以下のような[**リスト; list**](https://elixirschool.com/ja/lessons/basics/collections/#%E3%83%AA%E3%82%B9%E3%83%88)があります

```elixir
iex> l = [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
```

- (`iex`は Elixir の REPL です。ターミナルから`iex`と実行すれば起動でき、Elixir コードを実行できます)
- `=`がでてきましたが、そもそも Elixir では`=`は**マッチ演算子**です。「代入」演算子ではありません
- ここでは左辺の`l`という変数にはいかなる条件も存在しない(いわば自由変数である)ので、
  右辺のリストをまるごと「受け取る」ようなかたちで「マッチ」します
- この演算の結果として、`l`には右辺のリストが代入されたような格好になります
  - つまり`l`は右辺のリストで**束縛; bind**されました。意味(値)を持ち、「自由」ではなくなったのです
- その証拠に、こんなことをしてみましょう

```elixir
iex> [1, 2, 3, 4, 5] = m
** (CompileError) iex:1: undefined function m/0
```

- `m`は新しい変数ですが、どこにも定義されていません。Elixir はこれを`m/0`という関数と解釈しようとしましたが、当然見つからないのでエラーです
  - `/0`というのは Erlang/Elixir の関数を指し示すときに使う表記法です。`/`のあとに引数の数を付けます
- 一方、

```elixir
iex> [1, 2, 3, 4, 5] = l
[1, 2, 3, 4, 5]
```

- **`l`であればこの式は成り立ちます！**
- `l`はすでにリストで束縛されており、かつ、ここでの左辺と内容が全く同じだからです
- これで、Elixir の`=`が「代入」ではなくあくまで「マッチ演算子」であることがはっきりしました

---

- マッチ演算子の左辺では、様々な「条件」を表現できます
  - すでに、「全く無条件」(= 新しい変数の導入)と、「(何らかのリストのような、)固定の値」という 2 パターンが登場しました
- たとえば、「空でないリスト」のような条件もあります

```elixir
iex> [head | tail] = [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
iex> head
1
iex> tail
[2, 3, 4, 5]
```

- `[head | tail]`という構文は、空でないリストにマッチし、
  - `head`を先頭の値
  - `tail`を先頭を覗いたリスト
- でそれぞれ束縛します
- 空のリストを与えれば、

```elixir
iex> [head | tail] = []
** (MatchError) no match of right hand side value: []
```

- エラーとなります
- ほかにもパターンマッチで利用できる条件・束縛の表記はたくさんありますので徐々に慣れていってください

---

- パターンマッチはマッチ演算子`=`以外にも、
  - `case`式
  - 関数の引数部分
- で行うことができます。例えば以下のようなパターンマッチは頻出です
  - 下記コード例は`iex`で直接実行するには工夫が必要なので、見るだけで OK

```elixir
case some_list do
    []         -> "empty!"
    [head | _] -> "first value: #{head}"
end

def func([]) do
    "empty!"
end
def func([head | _]) do
    "first value: #{head}"
end
```

- (パターンマッチで、マッチした値を変数に束縛しない場合は`_`で始まるプレースホルダ変数が使えます)
- 見て分かる通り、`case`文でのパターンマッチは**これすなわち条件分岐にほかなりません**
  - Elixir では**真偽値; boolean**を条件とする場合には`if`を使いますが、
    それ以外の値を対象に条件分岐する場合、`case`が最も頻繁に登場します
