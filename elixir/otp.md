## 実習: OTPに触れる

- Erlangには**OTP**という枠組みがあります
    - 軽量プロセスを構成要素とし、
    - プロセス間のメッセージパッシングによって協調処理を実現、
    - OTPアプリケーション内部のプロセスに階層構造をもたせ、
    - 上位のプロセスが回のプロセスの死活監視(**Supervise**)をし、
    - 個々のプロセスで例外発生(クラッシュ)した場合は、
      そのプロセスを殺して新たな同等のプロセスを立ち上げる
- こういった仕組みによって、
    - 例外による影響の局所化
    - 容易な並列処理の実装
    - 必要に応じて状態の保持
- などを可能にします

---

- 気づいた方もいるかもしれませんが、Elixirには"Class"とか"Object"と言った概念がでてきません
- アプリケーション内部に「状態」をもたせようと思った場合、 **純粋; pure** なmoduleと関数だけでは不足します
    - ここでいう純粋とは、関数が内部状態や副作用を持たず、同じ入力には常に同じ出力を返す性質
- Erlang/Elixirでは**状態は軽量プロセスに保持**させます
    - 状態を持っているプロセスに、適切な **メッセージ; message** を送ってクエリや更新を要求します
        - まさしく、VM内のプロセス間に**クライアント・サーバモデルの関係が当てはまる**と思ってください
        - メッセージは各プロセスの**メールボックス; mailbox**に届けられ、FIFOで処理されます

---

### 見てみる

- プロジェクトディレクトリで`iex -S mix`してみましょう
- `:observer`というErlangの機能を利用して、VMの内部状態を観測してみます

```
$ iex -S mix
Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false]

Compiling 1 file (.ex)
Generated myapp app
Interactive Elixir (1.5.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> :observer.start()
:ok
```

- GUIが立ち上がるはずです

[![observer](observer.png)](observer.png)

- まず"Applications"タブを見てみるのがいいでしょう
- VM内で起動しているアプリケーションが一覧できます
    - `elixir`自体も実行時アプリケーションを持っていたり、`mix`もアプリケーションだったり
- そして、アプリケーションを選択すると、そのアプリケーションのプロセスツリー(**Supervision Tree**)が一覧できます
    - プロセスにはそれぞれ**PID**がついています
    - 一部のプロセスには名前がついています(**registered name**)

---

### 立ち上げてみる

- ここで`myapp`が「アプリケーション」欄にないことに気づきます
- `myapp`はまだ`escript`としてしか実装しておらず、特に状態を持たせようともしていなかったため、
  「アプリケーション」として定義していないのです
- 定義してみましょう
